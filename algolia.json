[{"categories":["Node.js"],"content":"typeORM transaction시 버전차에 따른 방법 변화","date":"2023-02-25","objectID":"/posts/230225-typeorm-transaction%EC%97%90%EC%84%9C-repository-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/","tags":["typeORM","mySQL"],"title":"typeORM transaction에서 repository 사용하기","uri":"/posts/230225-typeorm-transaction%EC%97%90%EC%84%9C-repository-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"\u003c사진: unsplash\u003e #project_review #typeorm ","date":"2023-02-25","objectID":"/posts/230225-typeorm-transaction%EC%97%90%EC%84%9C-repository-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/:0:0","tags":["typeORM","mySQL"],"title":"typeORM transaction에서 repository 사용하기","uri":"/posts/230225-typeorm-transaction%EC%97%90%EC%84%9C-repository-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"transaction 구성중 Entity가 아닌 Repository 사용시 typeORM에서 transaction을 사용하는 방법은 몇가지가 있지만, 복잡한 service단의 처리에서는 아래의 queryRunner 방식이 더 적합할것 같아서 dataSource.createQueryRunner() 방식을 사용했다.1 // transaction으로 묶어주기 const queryRunner = dataSource.createQueryRunner(); await queryRunner.connect(); await queryRunner.startTransaction(); try { // feed 저장 let newTempFeed: Feed = plainToInstance(FeedDto, feedInfo); const tempFeed = await FeedRepository.createFeed(newTempFeed); //\u003c- 문제!! // ... 추가 코드들 } catch (err) { await queryRunner.rollbackTransaction(); throw new Error(`createTempFeed TRANSACTION error: ${err}`); } finally { await queryRunner.release(); } ","date":"2023-02-25","objectID":"/posts/230225-typeorm-transaction%EC%97%90%EC%84%9C-repository-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/:1:0","tags":["typeORM","mySQL"],"title":"typeORM transaction에서 repository 사용하기","uri":"/posts/230225-typeorm-transaction%EC%97%90%EC%84%9C-repository-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"문제 - commit 중복으로 rollbackTransaction 실패 FeedRepository는 이미 그 자체로 코드 실행시 transaction이 따로이 실행된다. 즉, 여기서 이미 commit이 이루어진다는 뜻! 따라서 rollbackTransaction을 하는데 있어 FeedRepository.createFeed 코드는 이미 commit이 되었기에 rollback 해당 대상에서 벗어나게 된다. 위와 같이 FeedRepository에서 START TRANSACTION이 따로이 한번 더 일어나고, 아직 실행중이지만 도중에 COMMIT이 되어버림을 확인할 수 있다. ","date":"2023-02-25","objectID":"/posts/230225-typeorm-transaction%EC%97%90%EC%84%9C-repository-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/:1:1","tags":["typeORM","mySQL"],"title":"typeORM transaction에서 repository 사용하기","uri":"/posts/230225-typeorm-transaction%EC%97%90%EC%84%9C-repository-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"해결 - withRepository 메소드 고민을 해보자! transaction의 dataSource.manager는 따로 동작한다. 즉, 곰곰히 생각해보면 FeedRepository 단독실행이 아닌 아닌 저 transaction단에서 동작하는 범주 안에서 코딩이 이루어져야 한다. 2가지 방안이 떠올랐다. 첫번째는 FeedRepository안에 만들어놓은 메소드를 포기하고 따로이 다시금 transaction의 try문단 안에 코딩을 하는 것이고, 다른 하나는 저 FeedRepository를 어떻게든 transaction 동작 범주 안으로 우겨넣는 방법일 것이다. 다시금 코딩을 하자니 상당히 비효율적이고, 이건 도저히 아니라는 판단이 들었다. 그럼 우겨넣는 방법인데… 구글링을 해봐도 typeORM의 버전 업그레이드로 관련문서의 수도 적었고, 있다하더라도 대개 nestJS의 customRepository 관련 문서였다. 최후의 수단으로 IDE에서 사용가능한 메소드를 쭉 하나하나 살펴봤다. 그러다가 찾은 메소드 withRepository Note manager.withRepository 지정된 리포지토리에서 새 리포지토리 인스턴스를 생성하고 현재 EntityManager 인스턴스를 해당 리포지토리로 설정합니다. 트랜잭션에서 사용자 지정 리포지토리로 작업하는 데 사용됩니다. 아~주 적절하다! 이렇게까지 복잡했던 이유는, 만약 해당 코드가 단순히 기본 Entity라면 const tempFeed = await queryRunner.manager.save(Feed, newTempFeed); 간단하게 뭐 이렇게 나가면 된다. 하지만 단순한 Entity가 아닌, 이미 일련의 실행과정을 코딩해놓은 Repository이기에 아래와 같이 withRepository 메소드를 사용한다. 그러면 해당 레포에서 static으로 박아놓은 .createFeed라는 하위 메소드도 연결해서 사용가능하다. const tempFeed = await queryRunner.manager .withRepository(FeedRepository) .createFeed(newTempFeed); 테스트 결과 빠르게 나머지 코드들을 세팅하고 테스트를 해본다. 이제 정상적으로 START TRANSACTION이 한번 일어나고, 의도적인 에러를 터트려 롤백하게 했더니 마지막으로 무사히 ROLLBACK이 이루어진다. transaction안에 AWS S3 objectCommand까지 있어 코드가 좀 어지러웠지만 그래도 예상되는 모든 Transaction-Rollback 테스트가 모두 통과되어 되어 한시름 놓았다. getConnection() 방식은 typeORM 0.3.x에서 deprecated 되었고, dataSource 방식으로 대체하면 된다. ↩︎ ","date":"2023-02-25","objectID":"/posts/230225-typeorm-transaction%EC%97%90%EC%84%9C-repository-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/:1:2","tags":["typeORM","mySQL"],"title":"typeORM transaction에서 repository 사용하기","uri":"/posts/230225-typeorm-transaction%EC%97%90%EC%84%9C-repository-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"\u003c사진: unsplash\u003e #project_review ","date":"2023-02-16","objectID":"/posts/230216-node.js-%EB%B0%B1%EC%97%94%EB%93%9Ctypescript-+-typeorm%EC%9C%BC%EB%A1%9C-%EB%AC%B4%ED%95%9C-%EB%8C%80%EB%8C%93%EA%B8%80-%EA%B0%80%EA%B3%B5%ED%95%98%EA%B8%B0/:0:0","tags":["TypeScript","typeORM"],"title":"Node.js 백엔드TypeScript + typeORM으로 무한 대댓글 가공하기","uri":"/posts/230216-node.js-%EB%B0%B1%EC%97%94%EB%93%9Ctypescript-+-typeorm%EC%9C%BC%EB%A1%9C-%EB%AC%B4%ED%95%9C-%EB%8C%80%EB%8C%93%EA%B8%80-%EA%B0%80%EA%B3%B5%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"기능 구현 목표 댓글, 대댓글… 대댓글 등의 무한대댓글 구조 typeORM의 Entity를 연계한 createQueryBuilder 등을 지향하며, 최대한 직접적인 QueryRunner 방식 지양 삭제 및 비공개 댓글 가림 json 출력시 불필요한 요소 제거 (특히 Date 타입에서 !! ) ","date":"2023-02-16","objectID":"/posts/230216-node.js-%EB%B0%B1%EC%97%94%EB%93%9Ctypescript-+-typeorm%EC%9C%BC%EB%A1%9C-%EB%AC%B4%ED%95%9C-%EB%8C%80%EB%8C%93%EA%B8%80-%EA%B0%80%EA%B3%B5%ED%95%98%EA%B8%B0/:1:0","tags":["TypeScript","typeORM"],"title":"Node.js 백엔드TypeScript + typeORM으로 무한 대댓글 가공하기","uri":"/posts/230216-node.js-%EB%B0%B1%EC%97%94%EB%93%9Ctypescript-+-typeorm%EC%9C%BC%EB%A1%9C-%EB%AC%B4%ED%95%9C-%EB%8C%80%EB%8C%93%EA%B8%80-%EA%B0%80%EA%B3%B5%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"가장 오랜시간을 지연시켰던 Blocker #typeORM createQueryBuilder 메소드로 출력시 2023-02-14T08:55:24.090Z // ^ ^^^^ \u003c- 거추장스럽다. 이런 식으로 나오는 문제가 있는데 꽤나 씨름했다. 우선 Entity의 Date type은 datetime이 아닌 timestamp로 했다. mySQL에서의 출력은 DB가 설치된 서버의 시간대를 따르기에 아래와 같이 문제가 없다. select * from comments where feedId = 1 2023-02-14 17:55:24.106558 -- 이게 실제 한국 시간 문제는, typeORM에서의 repository + createQueryBuilder를 이용한 직접 출력이다. typeORM의 .find나 createQueryBuilder 메소드를 통해 출력을 하게 되면 ISO 8601 형식으로 내보내지기 때문에 먼저 보여줬던 예와 같이 문제가 생기는데 다시 정리하면 아래와 같다. 시간대 안맞음 (실제 시간은 17:55:24) 시간대 앞 뒤로 T, 090Z와 같은 부가요소가 함께 출력 현재 데이터를 출력하려는 query는 다음과 같다. export const CommentRepository = dataSource.getRepository(Comment).extend({ async getCommentList(id: number) { return await this.createQueryBuilder('comment') .leftJoinAndSelect('comment.children', 'children') .leftJoinAndSelect('comment.user', 'user') .leftJoinAndSelect('comment.feed', 'feed') .leftJoinAndSelect('children.user', 'childrenUser') .leftJoinAndSelect('children.feed', 'childrenFeed') .where('comment.feed = :id', { id }) .andWhere('comment.parentId IS NULL') .orderBy('comment.id', 'ASC') .addOrderBy('children.id', 'ASC') .setParameter('id', id) .getMany(); }, } ","date":"2023-02-16","objectID":"/posts/230216-node.js-%EB%B0%B1%EC%97%94%EB%93%9Ctypescript-+-typeorm%EC%9C%BC%EB%A1%9C-%EB%AC%B4%ED%95%9C-%EB%8C%80%EB%8C%93%EA%B8%80-%EA%B0%80%EA%B3%B5%ED%95%98%EA%B8%B0/:2:0","tags":["TypeScript","typeORM"],"title":"Node.js 백엔드TypeScript + typeORM으로 무한 대댓글 가공하기","uri":"/posts/230216-node.js-%EB%B0%B1%EC%97%94%EB%93%9Ctypescript-+-typeorm%EC%9C%BC%EB%A1%9C-%EB%AC%B4%ED%95%9C-%EB%8C%80%EB%8C%93%EA%B8%80-%EA%B0%80%EA%B3%B5%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"해결방안 ","date":"2023-02-16","objectID":"/posts/230216-node.js-%EB%B0%B1%EC%97%94%EB%93%9Ctypescript-+-typeorm%EC%9C%BC%EB%A1%9C-%EB%AC%B4%ED%95%9C-%EB%8C%80%EB%8C%93%EA%B8%80-%EA%B0%80%EA%B3%B5%ED%95%98%EA%B8%B0/:3:0","tags":["TypeScript","typeORM"],"title":"Node.js 백엔드TypeScript + typeORM으로 무한 대댓글 가공하기","uri":"/posts/230216-node.js-%EB%B0%B1%EC%97%94%EB%93%9Ctypescript-+-typeorm%EC%9C%BC%EB%A1%9C-%EB%AC%B4%ED%95%9C-%EB%8C%80%EB%8C%93%EA%B8%80-%EA%B0%80%EA%B3%B5%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"1. local 시간대 맞추기 우선, 이를 local의 시간대로 맞추기 위해 아래와 같이 DataSource 설정에 timezone: 'Z' 를 추가하여 local 시간대로 출력되게끔 한다. const dataSource = new DataSource({ type: process.env.TYPEORM_CONNECTION, host: process.env.TYPEORM_HOST, port: process.env.TYPEORM_PORT, username: process.env.TYPEORM_USERNAME, password: process.env.TYPEORM_PASSWORD, database: process.env.TYPEORM_DATABASE, entities: [__dirname + '/../**/*.entity.{js,ts}'], timezone: 'Z', // \u003c-- 이렇게 추가 logging: Boolean(process.env.TYPEORM_LOGGING), synchronize: Boolean(process.env.TYPEORM_SYNCHRONIZE), charset: 'utf8mb4', }); // 출력시, 2023-02-14T17:55:24.106Z 자 이제 시간대는 맞춰졌다. ","date":"2023-02-16","objectID":"/posts/230216-node.js-%EB%B0%B1%EC%97%94%EB%93%9Ctypescript-+-typeorm%EC%9C%BC%EB%A1%9C-%EB%AC%B4%ED%95%9C-%EB%8C%80%EB%8C%93%EA%B8%80-%EA%B0%80%EA%B3%B5%ED%95%98%EA%B8%B0/:3:1","tags":["TypeScript","typeORM"],"title":"Node.js 백엔드TypeScript + typeORM으로 무한 대댓글 가공하기","uri":"/posts/230216-node.js-%EB%B0%B1%EC%97%94%EB%93%9Ctypescript-+-typeorm%EC%9C%BC%EB%A1%9C-%EB%AC%B4%ED%95%9C-%EB%8C%80%EB%8C%93%EA%B8%80-%EA%B0%80%EA%B3%B5%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"2. 시간 구분자 제거 다음은 문제의 저 T와 Z를 날려보자. dateStrings: true, DataSouce 연결 설정에 이걸 넣어준다. const dataSource = new DataSource({ type: process.env.TYPEORM_CONNECTION, host: process.env.TYPEORM_HOST, port: process.env.TYPEORM_PORT, username: process.env.TYPEORM_USERNAME, password: process.env.TYPEORM_PASSWORD, database: process.env.TYPEORM_DATABASE, entities: [__dirname + '/../**/*.entity.{js,ts}'], timezone: 'Z', dateStrings: true, // \u003c-- 이렇게 추가 logging: Boolean(process.env.TYPEORM_LOGGING), synchronize: Boolean(process.env.TYPEORM_SYNCHRONIZE), charset: 'utf8mb4', }) 그리고 다시 출력을 해보면 2023-02-14 17:55:24.106558 드디어 불필요한 알파벳은 사라졌다…라기보단, 그런데 더 거추장스럽게도 밀리초(?)로 바뀌었다. 이제 이걸 제거해보자! ","date":"2023-02-16","objectID":"/posts/230216-node.js-%EB%B0%B1%EC%97%94%EB%93%9Ctypescript-+-typeorm%EC%9C%BC%EB%A1%9C-%EB%AC%B4%ED%95%9C-%EB%8C%80%EB%8C%93%EA%B8%80-%EA%B0%80%EA%B3%B5%ED%95%98%EA%B8%B0/:3:2","tags":["TypeScript","typeORM"],"title":"Node.js 백엔드TypeScript + typeORM으로 무한 대댓글 가공하기","uri":"/posts/230216-node.js-%EB%B0%B1%EC%97%94%EB%93%9Ctypescript-+-typeorm%EC%9C%BC%EB%A1%9C-%EB%AC%B4%ED%95%9C-%EB%8C%80%EB%8C%93%EA%B8%80-%EA%B0%80%EA%B3%B5%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"3. 정밀 초단위는 제거하고 시,분까지만 출력 여기서 정말 많이 찾아보고 공부했다. typeORM의 queryRunner를 사용하거나, createQueryBuilder에서 getRawMany()를 사용해 자료를 뽑아낸다면, mySQL의 출력방식을 따르기때문에 SQL의 query문에 직접적인 수정을 가하여 컬럼값을 조정할 수가 있다. (또는 toISOString()과 같은 메소드를 사용하여도 된다.) 예시) select SUBSTRING(created_at, 1, 19) AS created_at from comments 결과 2023-02-14 17:55:24 하지만, 위에서 쓰고 있는 Entity에서 그대로 가져오는 getMany() 메소드를 이용해 자료를 가져오게 되면, 이런 방법이 불가하다. 이것도 확실한지는 모르겠는데 며칠을 찾아보고 시도해본 결과, TypeORM의 getRawMany() 메서드는 쿼리 결과를 직접적으로 반환하는 반면, getMany() 메서드는 Entity 객체를 반환한다. 때문에 select \u003ccolumn\u003e에 바로 수정을 가하게 되면 Entity의 type을 그대로 가져다 쓰는 특성상, 이 컬럼의 type error가 난다. 즉, select 또는 addSelect로 Alias하거나 수정을 함과 동시에 출력이 되지 않고 되려 해당 컬럼이 사라진다. 이러한 상태로의 해결방법은 Entity에서 직접 Alias 해줘야 하는데, 또 이렇게 되면 CreateDateColumn의 데코레이션 default 옵션이 깨진다.(피나는 시도 결과 ;; ㅠ) 때문에 결국 양자택일을 하는 수밖에 없었다. getMany() 방식을 포기하거나, service단에서 복잡하지만 수정을 가한다. 굳이 getMany() 방식을 고집하는 이유는 다음과 같다. 현재 저 코드 Comment Entity에서 가져오며, 해당 Entity는 parent와 children\u003cComment[]\u003e의 자기참조 컬럼을 가지고 있는 Tree 구조로 이루어져 있다. 그리고 typeORM의 createQueryBuilder는 이 구조 특성을 그대로 살려서 출력이 가능하다. 반대로 query runner 방식으로 처리하여 같은 tree 구조를 출력하려면, repository단에서 굉장히 지독히도 가독성이 떨어지는 코드로 구현된다(물론 현재의 내 수준에서;;).1 typeORM의 Tree 방식으로 출력가능한 getMany() 메소드를 포기하게 된다면, repository단에서의 query가 생각보다 복잡하게 된다. 추후 유지보수의 가능성을 염두에 둔다. 대댓글 뿐만 아니라, 대대댓글 등의 무한 대댓글 구조역시 가능하도록 진행을 하는데 현재 Date type만의 수정을 원한다면, service단에서의 조정이 맞다는 판단이 들었다. 때문에 다음과 같이 service단에서 코드를 재귀함수(무한대댓글을 구현하기 위해)로 추가하며, 원하는 결과를 가져올 수 있도록 조정한다. 추가코드 // comments.service.ts // 가공영역에 대한 재귀함수 const formatComment = (comment: any, userId: number): any =\u003e { const isPrivate = comment.is_private === true \u0026\u0026 comment.user.id !== userId; const isDeleted = comment.deleted_at !== null; const formattedComment = { // 로그인 사용자의 비밀덧글 조회시 유효성 확인 및 삭제된 덧글 필터링 ...comment, comment: isDeleted ? '## DELETED_COMMENT ##' : isPrivate ? '## PRIVATE_COMMENT ##' : comment.comment, // Date 타입의 컬럼에서 불필요한 밀리초 부분 제외 created_at: comment.created_at.substring(0, 19), updated_at: comment.updated_at.substring(0, 19), deleted_at: comment.deleted_at ? comment.deleted_at.substring(0, 19) : null, // 대댓글 영역 -------------------------------- children: comment.children ? comment.children.map((child: any) =\u003e formatComment(child, userId)) : [], }; return formattedComment; }; 이후 리팩토링을 하며 만들어진 최종 대댓글 API 결과. // 현재 로그인 유저의 id는 16번 [ { \"id\": 95, // \u003c- 원댓글 \"created_at\": \"2023-02-14 21:36:43\", // \u003c-- 짜잔!! 드디어 깔끔한 마무리! \"updated_at\": \"2023-02-14 21:36:43\", \"deleted_at\": null, \"user\": { \"id\": 3, \"nickname\": \"103\", \"email\": \"serswell2@hc360.com\" }, \"feed\": { \"id\": 96, \"title\": \"vulputate luctus cum sociis\" }, \"comment\": \"nulla tellus in sagittis\", \"is_private\": false, \"children\": [ // \u003c- 1차 대댓글 배열 { \"id\": 212, // \u003c- 대댓글 \"created_at\": \"2023-02-14 21:36:43\", \"updated_at\": \"2023-02-14 21:36:43\", \"deleted_at\": null, \"user\": { \"id\": 16, \"nickname\": \"test nickname6\", \"email\": \"test6@test.com\" }, \"comment\": \"댓글 수정 테스트\", \"is_private\": false, \"children\": [ // \u003c- 2차 대댓글 배열 { \"id\": 220, // \u003c- 대댓글에 대한 대댓글 \"created_at\": \"2023-02-16 20:04:19\", // \u003c-여기까지 재귀함수가 \"updated_at\": \"2023-02-16 20:04:19\", // 잘 적용되고 있음을 확인!! \"deleted_at\": null, \"user\": { \"id\": 16, \"nickname\": \"test nickname6\", \"email\": \"test6@test.com\" }, \"comment\": \"레포지토리 커멘트 생성 테스트\", \"is_private\": true, \"children\": [] } ] }, { \"id\": 214, \"created_at\": \"2023-02-14 21:36:43\", \"updated_at\": \"2023-02-14 21:36:43\", \"deleted_at\": null, \"user\": { \"id\": 15, // 다른 유저가 작성한 비공개 대댓글 \"nickname\": \"test nickname5\", \"email\": \"test5@test.com\" }, \"comment\": \"## PRIVATE_COMMENT ##\", // \u003c- 여기서도 정상적 차단 확인 \"is_private\": true, \"children\": [] }, { \"id\": 215, \"created_at\": \"2023-02-14 21:36:43\", \"updated_at\": \"2023-02-16 20:03:42\", \"deleted_at\": \"2023-02-16 20:03:42\", // \u003c- 본인의 삭제한 댓글 \"user\": { \"id\": 16, \"nickname\": \"test nickname6\", \"email\": \"test6@test.com\" }, \"comment\": \"## DELETED_COMMENT ##\", // \u003c- 정상적 차단 확인 \"is_private\": false, \"children\": [] } ] }, ] 아주 이쁘게 잘 나왔다. typeORM 관련하여 전체적으로 내가 원하는 샘플코드는 구체적으로 검색해보기가 힘들어, 대부분 typeORM 공식문서를 참고하며 진행하였고, 생각보다 공식문서가 굉장히 잘되어 있어 놀랐다. (공식문서 속에서 원하는 정보 찾는","date":"2023-02-16","objectID":"/posts/230216-node.js-%EB%B0%B1%EC%97%94%EB%93%9Ctypescript-+-typeorm%EC%9C%BC%EB%A1%9C-%EB%AC%B4%ED%95%9C-%EB%8C%80%EB%8C%93%EA%B8%80-%EA%B0%80%EA%B3%B5%ED%95%98%EA%B8%B0/:3:3","tags":["TypeScript","typeORM"],"title":"Node.js 백엔드TypeScript + typeORM으로 무한 대댓글 가공하기","uri":"/posts/230216-node.js-%EB%B0%B1%EC%97%94%EB%93%9Ctypescript-+-typeorm%EC%9C%BC%EB%A1%9C-%EB%AC%B4%ED%95%9C-%EB%8C%80%EB%8C%93%EA%B8%80-%EA%B0%80%EA%B3%B5%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"Entity 아! Entity에서 기본적으로 들어가는 id와 created_at, updated_at 등은 Base Entity로 따로 만들어 Entity 작업시 반복적으로 기입하지 않고 Embeded Entityes 방식으로 처리하였다.2 // comment.entity.ts @Entity('comments') export class Comment extends Base { @ManyToOne(type =\u003e User, users =\u003e users.comment, { nullable: false }) @JoinColumn({ name: 'userId' }) user: User; @ManyToOne(type =\u003e Feed, feeds =\u003e feeds.comment, { nullable: false }) @JoinColumn({ name: 'feedId' }) feed: Feed; @Column({ length: 1000 }) comment: string; @Column('boolean', { default: false }) is_private: boolean; @ManyToOne(type =\u003e Comment, comment =\u003e comment.children) @JoinColumn({ name: 'parentId' }) parent: Comment; @OneToMany(type =\u003e Comment, comment =\u003e comment.parent) children: Comment[]; } service단!! // comments.service.ts // 무한 대댓글의 경우, 재귀적으로 호출되는 함수 const formatComment = (comment: any, userId: number): any =\u003e { const isPrivate = comment.is_private === true \u0026\u0026 comment.user.id !== userId; const isDeleted = comment.deleted_at !== null; const formattedComment = { ...comment, // 로그인 사용자의 비밀덧글 조회시 유효성 확인 및 삭제된 덧글 필터링 comment: isDeleted ? '## DELETED_COMMENT ##' : isPrivate ? '## PRIVATE_COMMENT ##' : comment.comment, // Date 타입의 컬럼에서 불필요한 밀리초 부분 제외 created_at: comment.created_at.substring(0, 19), updated_at: comment.updated_at.substring(0, 19), deleted_at: comment.deleted_at ? comment.deleted_at.substring(0, 19) : null, // 대댓글 영역 -------------------------------- children: comment.children ? comment.children.map((child: any) =\u003e formatComment(child, userId)) : [], }; return formattedComment; }; const getCommentList = async (id: number, userId: number) =\u003e { const result = await CommentRepository.getCommentList(id); const formattedResult = [...result].map((comment: any) =\u003e formatComment(comment, userId) ); return formattedResult; }; ","date":"2023-02-16","objectID":"/posts/230216-node.js-%EB%B0%B1%EC%97%94%EB%93%9Ctypescript-+-typeorm%EC%9C%BC%EB%A1%9C-%EB%AC%B4%ED%95%9C-%EB%8C%80%EB%8C%93%EA%B8%80-%EA%B0%80%EA%B3%B5%ED%95%98%EA%B8%B0/:3:4","tags":["TypeScript","typeORM"],"title":"Node.js 백엔드TypeScript + typeORM으로 무한 대댓글 가공하기","uri":"/posts/230216-node.js-%EB%B0%B1%EC%97%94%EB%93%9Ctypescript-+-typeorm%EC%9C%BC%EB%A1%9C-%EB%AC%B4%ED%95%9C-%EB%8C%80%EB%8C%93%EA%B8%80-%EA%B0%80%EA%B3%B5%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"Repository단!!! // comment.repository.ts export const CommentRepository = dataSource.getRepository(Comment).extend({ async getCommentList(id: number) { return await this.createQueryBuilder('comment') .withDeleted() .addSelect(['user.id', 'user.nickname', 'user.email']) .addSelect(['feed.id', 'feed.title']) .addSelect([ 'childrenUser.id', 'childrenUser.nickname', 'childrenUser.email', ]) .addSelect([ 'childrenUser2.id', 'childrenUser2.nickname', 'childrenUser2.email', ]) .leftJoin('comment.user', 'user') .leftJoin('comment.feed', 'feed') .leftJoinAndSelect('comment.children', 'children') .leftJoin('children.user', 'childrenUser') .leftJoinAndSelect('children.children', 'children2') .leftJoin('children2.user', 'childrenUser2') .where('comment.feed = :id', { id }) .andWhere('comment.parentId IS NULL') .orderBy('comment.id', 'ASC') .addOrderBy('children.id', 'ASC') .setParameter('id', id) .getMany(); }, } fastfive 기업과제에서 수행했던 자기참조방식의 대댓글 구현 여기서 query runner방식은 이미 해봤기에 이번에는 특히나 typeORM의 queryBuilder 문법으로만 진행해보고 싶었다. ↩︎ TypeORM - Amazing ORM for TypeScript and JavaScript (ES7, ES6, ES5). Supports MySQL, PostgreSQL, MariaDB, SQLite, MS SQL Server, Oracle, WebSQL databases. Works in NodeJS, Browser, Ionic, Cordova and Electron platforms. ↩︎ ","date":"2023-02-16","objectID":"/posts/230216-node.js-%EB%B0%B1%EC%97%94%EB%93%9Ctypescript-+-typeorm%EC%9C%BC%EB%A1%9C-%EB%AC%B4%ED%95%9C-%EB%8C%80%EB%8C%93%EA%B8%80-%EA%B0%80%EA%B3%B5%ED%95%98%EA%B8%B0/:3:5","tags":["TypeScript","typeORM"],"title":"Node.js 백엔드TypeScript + typeORM으로 무한 대댓글 가공하기","uri":"/posts/230216-node.js-%EB%B0%B1%EC%97%94%EB%93%9Ctypescript-+-typeorm%EC%9C%BC%EB%A1%9C-%EB%AC%B4%ED%95%9C-%EB%8C%80%EB%8C%93%EA%B8%80-%EA%B0%80%EA%B3%B5%ED%95%98%EA%B8%B0/"},{"categories":["env"],"content":"#chatGPT ","date":"2023-02-10","objectID":"/posts/230210-chatgpt-%EC%82%AC%EC%9A%A9%EA%B8%B0-whereclausebuilder-%ED%95%A8%EC%88%98%EB%A5%BC-%EB%AC%BC%EC%96%B4%EB%B3%B4%EC%95%98%EB%8B%A4./:0:0","tags":["chatGPT"],"title":"chatGPT 사용기 - whereClauseBuilder 함수를 물어보았다.","uri":"/posts/230210-chatgpt-%EC%82%AC%EC%9A%A9%EA%B8%B0-whereclausebuilder-%ED%95%A8%EC%88%98%EB%A5%BC-%EB%AC%BC%EC%96%B4%EB%B3%B4%EC%95%98%EB%8B%A4./"},{"categories":["env"],"content":"chatGPT에게 whereClauseBuilder 함수를 물어보았다. 원하는 정보는 javascript에서 mySQL DB로 query문을 작성하여 사용시, 반복되는 where절에 대해 함수화하여 재사용할 수 있는 방법 또는 예시 코드였다. 질문은 한글로 했고, 영어로 답변이 오는데 속도는 꽤 빠르다. 하지만 답변을 한글로 받고자 하면 꽤 오랜 지연이 발생한다. whereClauseBuilder함수란? I’m sorry, but you haven’t provided enough context for me to understand what you’re asking about. Could you please provide more information or specify what you’re looking to learn about “whereClauseBuilder”? 앞뒤 맥락 다 생략하고 바로 물었더니 잘 못알아듣는다. 추가 설명을 덧붙여 다시 물어보았다. javascript에서 mysql을 사용하는데 whereClauseBuilder 라는 방법이 있다고 한다. 이게 뭐야? It seems like you’re referring to a custom function named “whereClauseBuilder” in JavaScript that is used to build a WHERE clause for a SQL query to be used with a MySQL database. A WHERE clause is used in a SQL query to specify a condition for filtering the data that is returned by the query. The “whereClauseBuilder” function would be used to dynamically generate the WHERE clause based on some input parameters. It’s important to note that this function is likely a custom implementation and may not be a part of any official MySQL library or API. It is always a good practice to make sure that the custom code used in your applications is secure and does not leave any vulnerabilities that can be exploited. 상황과 맥락을 짚어주니 알아듣기 시작했다. 이제 추가적인 질문이 들어간다. javascript 코드 중 mysql의 where 절을 종종 사용한다. 이 때, 이 where 절을 만들어내는 함수의 예시를 보여줘 Sure! Here’s an example of a “whereClauseBuilder” function in JavaScript that can be used to dynamically generate a WHERE clause for a SQL query to be used with a MySQL database: function whereClauseBuilder(filters) { let whereClause = \"\"; if (filters \u0026\u0026 Object.keys(filters).length \u003e 0) { whereClause = \"WHERE \"; const filterKeys = Object.keys(filters); filterKeys.forEach((key, index) =\u003e { whereClause += `${key} = '${filters[key]}'`; if (index \u003c filterKeys.length - 1) { whereClause += \" AND \"; } }); } return whereClause; } This function takes in an object “filters” that represents the conditions for the WHERE clause. It then generates a WHERE clause by concatenating the key-value pairs in the “filters” object. The conditions are joined with the “AND” operator. Here’s an example usage of the function: \u003econst filters = { column1: \"value1\", column2: \"value2\" }; const whereClause = whereClauseBuilder(filters); console.log(whereClause); // Output: WHERE column1 = 'value1' AND column2 = 'value2' Please note that this is just one example of how a “whereClauseBuilder” function could be implemented. The specific implementation will depend on the needs of your application and the way that you want to handle the input parameters. 기본적인 whereClauseBuilder 함수 코드를 보여주고 이어서 자세한 설명을 덧붙여준다. 게다가 이 함수를 사용할 수 있는 예시 코드까지 친절하게 알려주고 출력시 로그까지 보여준다. 좋아. 이걸 typescript로 바꿔줘 Sure! Here’s an equivalent implementation of the “whereClauseBuilder” function in TypeScript: function whereClauseBuilder(filters: object): string { let whereClause = \"\"; if (filters \u0026\u0026 Object.keys(filters).length \u003e 0) { whereClause = \"WHERE \"; const filterKeys = Object.keys(filters); filterKeys.forEach((key, index) =\u003e { whereClause += `${key} = '${filters[key]}'`; if (index \u003c filterKeys.length - 1) { whereClause += \" AND \"; } }); } return whereClause; } In this implementation, the function signature includes type information for the input parameters and the returned value. This makes the code easier to understand and less prone to bugs caused by incorrect data types. 좋아, 여기서 Object.keys의 예를 보여줘 Sure! Object.keys() is a method in JavaScript that returns an array of the enumerable property names of an object. Here’s an example usage of Object.keys(): const obj = { name: \"John\", age: 30, city: \"New York\" }; const keys = Object.keys(obj); console.log(keys); // Output: [ \"name\", \"age\", \"city\" ] In the example, we have an object obj with three properties, name, age, and city. By calling Object.keys(obj), we get an array of strings containing the property names of the object. In the whereClauseBuilder function, we use Object.keys(fil","date":"2023-02-10","objectID":"/posts/230210-chatgpt-%EC%82%AC%EC%9A%A9%EA%B8%B0-whereclausebuilder-%ED%95%A8%EC%88%98%EB%A5%BC-%EB%AC%BC%EC%96%B4%EB%B3%B4%EC%95%98%EB%8B%A4./:0:1","tags":["chatGPT"],"title":"chatGPT 사용기 - whereClauseBuilder 함수를 물어보았다.","uri":"/posts/230210-chatgpt-%EC%82%AC%EC%9A%A9%EA%B8%B0-whereclausebuilder-%ED%95%A8%EC%88%98%EB%A5%BC-%EB%AC%BC%EC%96%B4%EB%B3%B4%EC%95%98%EB%8B%A4./"},{"categories":["env"],"content":"정말 흥미롭지 않은가? 이렇게 내가 원했던 부분들을 잘 짚어주다니, 정말 검색에 있어 새로운 패러다임이 만들어진게 아닐까 하는 생각이 든다. 혹자는 chatGPT가 기존의 구글링과 같은 검색방식을 대체할 수 있을거라고 하는데, 현재의 이 chatGPT버전을 두고 보자면 나는 조금 다르게 생각한다. 기존 구글링의 단점은 너무 많은 정보가 검색됨으로 인해, 그 중 내가 정말로 원하는 정보를 찾기 위해 하나하나 링크를 들여다봐야 하는 수고로움과 시간소요가 생기는 반면 여기서 생각하지 못했던 다른 방법이나 아이디어를 찾곤 할수 있다. 하지만 현재의 chatGPT는 이 부분이 빠진다. 즉, 내가 원하는 정보를 AI가 추려내고 콕집어 주기때문에 그것 말고는 다른 정보를 접해볼수 있는 기회가 없다. 즉, 완벽한 주입식 교육(?)이 되며, 또한 현재 버전에서는 제안해주는 정보의 신뢰성과 근거를 찾기가 애매하다. 뿐만 아니라 이러한 검색방식에 익숙해진다면, 자료의 교차검증이나 수많은 자료로부터 스스로 분석하고 결과를 도출해내는 사고가 사라진다. 물론, 사용하기에 따라 더 창의적이고 생산적으로 사용될 수 있겠지만 그 외의 수많은 이들은 편리함에만 익숙해질 것이다. 아마 개선? 추가되었으면 하는 부분을 말해본다면, chatGPT의 제안과 함께 현재 자료의 근거, 그리고 “함께 읽어볼만한 링크\"와 같은 추천 컨텐츠가 추가되면 어떨까 하는 생각을 해본다. 이 알고리즘 자체가 쉽진 않겠지만 (정치적, 경제적 이해관계를 비롯해서 다양한 이슈를 일으킬 수 있으니…) 본의 아니게 chatGPT의 단점이나 아쉬운 우려를 위주로 글이 쓰였는데, 사실 정말 엄청난 기술이다. 장점이야 워낙 많은 이들이 입이 닳도록 말하고 있고, 누구나 그저 한번만 질문을 해보면 알수 있을테니… 사용 팁이라면, 단순질문보다는 능동적이며 구체적인 연결된 질문이 본인이 원했던 답을 빠르게 찾을 수 있도록 도와준다. ","date":"2023-02-10","objectID":"/posts/230210-chatgpt-%EC%82%AC%EC%9A%A9%EA%B8%B0-whereclausebuilder-%ED%95%A8%EC%88%98%EB%A5%BC-%EB%AC%BC%EC%96%B4%EB%B3%B4%EC%95%98%EB%8B%A4./:0:2","tags":["chatGPT"],"title":"chatGPT 사용기 - whereClauseBuilder 함수를 물어보았다.","uri":"/posts/230210-chatgpt-%EC%82%AC%EC%9A%A9%EA%B8%B0-whereclausebuilder-%ED%95%A8%EC%88%98%EB%A5%BC-%EB%AC%BC%EC%96%B4%EB%B3%B4%EC%95%98%EB%8B%A4./"},{"categories":["env"],"content":"\u003c사진: DEVONtechnologies | DEVONthink, professional document and information management for the Mac and iOS\u003e tag : #devonthink source : Script: Replace link references with real links in Markdwon - DEVONthink / Tips - DEVONtechnologies Community 코딩을 공부하면서 정말 많은 웹 문서들을 참고하며 정리하게 된다. 그 중, 보관하고자 하는 문서는 주로 웹클리핑을 통해 정보를 수집한다. 이때, 클리핑 포맷은 보통 PDF로 하지만 가끔 code block내 스크롤이 있는 경우에는 PDF에서 짤린채로 수집되는 문제가 있어 MarkDown 포맷으로 클리핑을 한다. 나는 주로 아래 두 도구를 사용하여 자료를 정리한다. Obsidian(note taking app) DevonThink(note database) 이때, 웹클리핑은 Obsidian 노트내로 바로 삽입할 수 있는 방법도 있지만 1 파일자체에 Tag 및 Annotation 관리를 위해 DevonThink의 웹클리핑 tool을 사용한다. ","date":"2023-02-02","objectID":"/posts/230202-devonthink%EC%97%90%EC%84%9C-markdown%EC%9C%BC%EB%A1%9C-%EC%9B%B9%ED%81%B4%EB%A6%AC%ED%95%91%EC%8B%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%A3%BC%EC%86%8C-%EB%AC%B8%EC%A0%9C/:0:0","tags":["devonthink","markdown"],"title":"devonthink에서 markdown으로 웹클리핑시 이미지 주소 문제","uri":"/posts/230202-devonthink%EC%97%90%EC%84%9C-markdown%EC%9C%BC%EB%A1%9C-%EC%9B%B9%ED%81%B4%EB%A6%AC%ED%95%91%EC%8B%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%A3%BC%EC%86%8C-%EB%AC%B8%EC%A0%9C/"},{"categories":["env"],"content":"그런데 DevonThink의 MarkDown 웹클리핑 조금 이상한 부분이 있다. 일반적인 MarkDown 문법에서의 이미지 삽입 문법은 다음과 같다. ![image 설명](image 주소) 그런데 DevonThink의 웹클리퍼는 클리핑시 모든 부가적인 웹링크의 주소를 주석처리하는 경향이 보인다. 그래서 실제로 웹클리핑을 해보면 다음과 같이 MarkDown 변환 처리가 되어있음을 볼 수 있다. ![][1] \u003c!-- [1]은 주석번호 --\u003e 사실 이는 standard markdown 문법에서도 문제가 없기때문에 일반적인 다른 markdown 편집기에서도 이상없이 출력은 된다. 하지만… Obsidian 노트앱을 사용중이라면 Obsidian만의 변형 markdown 문법에서2 다른 문제를 야기한다. Obsidian에서는 이미지를 넣을때 이미지의 사이즈를 편하게 조절할 수 있는 문법이 있다.3 ![image 설명 |500](image 주소) \u003c!-- |숫자 는 이미지의 width를 설정해준다. |500x400 이렇게 넣으면 마크업 시, width 500, height 400을 설정해준다 --\u003e 이 때, 이미지의 주소가 주석으로 입력되면 위 문법이 먹히지 않게 된다. (변형문법의 단점 ;; ㅠ ) 이를 위해 이미지 주소 자리에 있는 주석번호를, 주석에 있는 원래의 이미지 링크로 바꿔주는 스크립트를 만들어 해당 파일에 스크립트를 적용하면 편하게 변환할 수 있다. 우선 스크립트는 다음과 같다. (() =\u003e { const app = Application(\"DEVONthink 3\") app.includeStandardAdditions = true; const records = app.selectedRecords(); records.forEach(r =\u003e { const links = getReferenceLinks(r.plainText()) r.plainText = replaceLinks(r.plainText(), links); }) })() function getReferenceLinks(txt) { const allLinks = [...txt.matchAll(/^\\[(\\d+)\\]:\\s+(.*)$/gm)]; const linkArray = {}; allLinks.forEach(l =\u003e { const index = l[1]; const URL = l[2]; linkArray[index] = URL; }) return linkArray; } function replaceLinks(txt, links) { console.log(links); Object.keys(links).forEach(k =\u003e { const URL = links[k]; const regEx = new RegExp(`]\\\\[${k}\\\\]`); txt = txt.replace(regEx, `](${URL})`); }) return txt; } 이를 적용하면 다음과 같이 주석으로 처리되었던 이미지 주소가 원 링크로 대체된다. ","date":"2023-02-02","objectID":"/posts/230202-devonthink%EC%97%90%EC%84%9C-markdown%EC%9C%BC%EB%A1%9C-%EC%9B%B9%ED%81%B4%EB%A6%AC%ED%95%91%EC%8B%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%A3%BC%EC%86%8C-%EB%AC%B8%EC%A0%9C/:0:1","tags":["devonthink","markdown"],"title":"devonthink에서 markdown으로 웹클리핑시 이미지 주소 문제","uri":"/posts/230202-devonthink%EC%97%90%EC%84%9C-markdown%EC%9C%BC%EB%A1%9C-%EC%9B%B9%ED%81%B4%EB%A6%AC%ED%95%91%EC%8B%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%A3%BC%EC%86%8C-%EB%AC%B8%EC%A0%9C/"},{"categories":["env"],"content":"DevonThink의 상단 툴바에 스크립트 넣기 macOS에 기본으로 설치되어 있는 스크립트 편집기를 열어서 위 코드를 넣는다. 이때 옵션에서 applescript가 아닌, javascript로 설정해줘야 한다. 그리고 devonthink에서 이 스크립트를 상단 툴바에 넣고 싶다면, devonthink의 상단 메뉴 중 script(아이콘) - open scripts folder 를 눌러 아래와 같이 파인더로 진입한다. Toolbar 폴더 내에 방금 만든 스크립트를 넣는다. 그럼 이제 toolbar 커스터마이징을 통해 아래와 같이 상단에 위치 시킬 수 있다. 물론 이 스크립트는 DevonThink의 smart rules에 등록시켜 자동으로 파일을 감지하여 사용하게끔 할 수도 있다. Obsidian Web Clipper Bookmarklet to save articles and pages from the web (for Safari, Chrome, Firefox, and mobile browsers) ↩︎ 나의 경우 변형 markdown 문법의 경우 웬만해서는 기피한다. 왜냐하면 MD파일이 해당 어플리케이션에 종속되는 문제가 생기기 때문이다. 하지만 그 사용이 너무나도 편해서 종종 상황에 따라 사용하기도 한다. ↩︎ Support image resize · Issue #2 · zoni/obsidian-export ↩︎ ","date":"2023-02-02","objectID":"/posts/230202-devonthink%EC%97%90%EC%84%9C-markdown%EC%9C%BC%EB%A1%9C-%EC%9B%B9%ED%81%B4%EB%A6%AC%ED%95%91%EC%8B%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%A3%BC%EC%86%8C-%EB%AC%B8%EC%A0%9C/:1:0","tags":["devonthink","markdown"],"title":"devonthink에서 markdown으로 웹클리핑시 이미지 주소 문제","uri":"/posts/230202-devonthink%EC%97%90%EC%84%9C-markdown%EC%9C%BC%EB%A1%9C-%EC%9B%B9%ED%81%B4%EB%A6%AC%ED%95%91%EC%8B%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%A3%BC%EC%86%8C-%EB%AC%B8%EC%A0%9C/"},{"categories":["env"],"content":"\u003c사진: unsplash\u003e tag : #webstorm source : Live template variables | WebStorm Documentation JavaScript로 코딩을 하다보면 적잖이 console.log()를 사용하게 된다. 보통 나는 간단하게 현재 흐름상 위치를 잡거나 객체를 확인할 때 자주 쓰는데, 많은 글자는 아니지만 그래도 같은걸 계속해서 타이핑하는게 귀찮아서 만들었다. 축약어는 console.log의 앞글자를 따서 cl로 단축 명령어를 만들었고, cl 단축어 입력 후 tab을 누르면 해당 WebStorm의 live template이 실행된다. 간단하게 다음과 같은 역할을 수행된다. console.log()를 입력 괄호 안에 변수명을 타이핑할 수 있도록 커서 위치 이동 변수명을 쓰면 따옴표 안에 동일한 변수가 들어가도록 설정 즉 console.log(\"변수 = \", 변수) 이러한 결과물을 만들어내고 터미널에는 아래와 같이 출력된다.(version 1) 변수 = 123 변수명을 타이핑한 후 tab키를 한번 더 누르면 따옴표 안의 왼쪽 설명쪽 변수로 커서가 이동한다. 그럼 상황에 맞게 console.log(\"변수의 위치는 service.ts의 signUp 함수 중' = \", 변수) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ // 추가설명 입력 뭐 이런식의 추가입력으로 사용할 수 있다. 만약 위에서 언급된 추가입력 부분을 자주 쓴다면 이 역시 WebStorm의 기능으로 템플릿 처리할 수가 있다.(version 2) 처음에는 변수를 셀렉트하고 감싸진 부분을 감지해서 사용하도록 surround templet으로 만들었었다. 그런데 어차피 몇 글자만 넣어도 자동으로 나머지 변수명이 팝업으로 뜨는 IDE 특성상, 그냥 입력하는게 더 편해서 다시 간단하게 만들었고 써보니 너무 편하다. ","date":"2023-02-02","objectID":"/posts/230202-webstorm-console.log%EB%B3%80%EC%88%98-%EC%9E%90%EB%8F%99%EC%99%84%EC%84%B1-%EB%9D%BC%EC%9D%B4%EB%B8%8C-%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A7%8C%EB%93%A4%EA%B8%B0/:0:0","tags":["webstorm"],"title":"WebStorm - console.log(변수) 자동완성 라이브 템플릿 만들기","uri":"/posts/230202-webstorm-console.log%EB%B3%80%EC%88%98-%EC%9E%90%EB%8F%99%EC%99%84%EC%84%B1-%EB%9D%BC%EC%9D%B4%EB%B8%8C-%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["env"],"content":"결과물 예시 version 1 version 2 ","date":"2023-02-02","objectID":"/posts/230202-webstorm-console.log%EB%B3%80%EC%88%98-%EC%9E%90%EB%8F%99%EC%99%84%EC%84%B1-%EB%9D%BC%EC%9D%B4%EB%B8%8C-%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A7%8C%EB%93%A4%EA%B8%B0/:0:1","tags":["webstorm"],"title":"WebStorm - console.log(변수) 자동완성 라이브 템플릿 만들기","uri":"/posts/230202-webstorm-console.log%EB%B3%80%EC%88%98-%EC%9E%90%EB%8F%99%EC%99%84%EC%84%B1-%EB%9D%BC%EC%9D%B4%EB%B8%8C-%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["env"],"content":"WebStrom Live Templates 추가 방법 ","date":"2023-02-02","objectID":"/posts/230202-webstorm-console.log%EB%B3%80%EC%88%98-%EC%9E%90%EB%8F%99%EC%99%84%EC%84%B1-%EB%9D%BC%EC%9D%B4%EB%B8%8C-%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A7%8C%EB%93%A4%EA%B8%B0/:1:0","tags":["webstorm"],"title":"WebStorm - console.log(변수) 자동완성 라이브 템플릿 만들기","uri":"/posts/230202-webstorm-console.log%EB%B3%80%EC%88%98-%EC%9E%90%EB%8F%99%EC%99%84%EC%84%B1-%EB%9D%BC%EC%9D%B4%EB%B8%8C-%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["env"],"content":"console.log Version 1 우선 WebStorm / Settings… (환경설정)에 진입한다. 그리고 메뉴 중 Live Templates 선택 (스샷 1번) 이어서 템플릿 추가 버튼(스샷 2번)을 누르면 위 스샷과 동일한 화면을 볼 수 있다. 스샷 4번에서 사용하기 편한 단축어를 설정한다. 이 단축어를 타이핑하면 팝업창에서 나타나게 된다. 그리고 스샷의 붉은 박스안과 같이 입력한다. (selector, variable과 같은 변수명은 아무거나 다른걸로 써도 무방) 이후, 스샷3번의 Edit Variables…를 클릭하면 아래와 같은 화면이 나타난다. 여기서 변수의 순서를 설정할 수 있는데, 이는 live template 실행 후 커서의 이동 순서를 나타낸다. 두번째 변수인 selector안에는 첫번째 변수의 내용이 그대로 들어감으로 첫번째 변수명을 써주면 복사효과(?)처럼 사용된다. 끝으로 스샷 5번 자리를 보면 아마 처음에 define... 와 같은 이름으로 되어있다. 클릭시 아래와 같은 창이 뜨는데, 이 단축어를 실행할 파일 종류를 선택할 수 있다. console.log니까 javascript/typescript를 선택해주면 된다. ","date":"2023-02-02","objectID":"/posts/230202-webstorm-console.log%EB%B3%80%EC%88%98-%EC%9E%90%EB%8F%99%EC%99%84%EC%84%B1-%EB%9D%BC%EC%9D%B4%EB%B8%8C-%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A7%8C%EB%93%A4%EA%B8%B0/:1:1","tags":["webstorm"],"title":"WebStorm - console.log(변수) 자동완성 라이브 템플릿 만들기","uri":"/posts/230202-webstorm-console.log%EB%B3%80%EC%88%98-%EC%9E%90%EB%8F%99%EC%99%84%EC%84%B1-%EB%9D%BC%EC%9D%B4%EB%B8%8C-%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["env"],"content":"console.log Version 2 서두에 언급했던 변수의 설명부분을 템플릿화 하고 싶다면 아래와 같이 진행. settings의 live templates에서 template test 박스안에 아래와 같이 입력 console.log('🔥🔥$FILE$/$FUNCTION$ :$LINE$ - $SELECTOR$ = ', $VARIABLE$) 그리고 위와 같이 변수를 설정한다. ","date":"2023-02-02","objectID":"/posts/230202-webstorm-console.log%EB%B3%80%EC%88%98-%EC%9E%90%EB%8F%99%EC%99%84%EC%84%B1-%EB%9D%BC%EC%9D%B4%EB%B8%8C-%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A7%8C%EB%93%A4%EA%B8%B0/:1:2","tags":["webstorm"],"title":"WebStorm - console.log(변수) 자동완성 라이브 템플릿 만들기","uri":"/posts/230202-webstorm-console.log%EB%B3%80%EC%88%98-%EC%9E%90%EB%8F%99%EC%99%84%EC%84%B1-%EB%9D%BC%EC%9D%B4%EB%B8%8C-%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["JavaScript"],"content":"tag : #typescript related link unknown-typescript typescript로 코딩을 하다가 어떤 타입인지 정의 내리기 힘든 상황에서 주로 any 를 사용한다. 물론 typescript의 성격상 any는 지양하는 것이 좋다. 오류를 검증하고 확인하려는 특성으로 엄격한 타입을 지정하려는 typescript에서 어떤 타입이나 가능하다는 성격의 any는 어쩌면 존재 자체가 모순인 타입이기도 하다. 하지만코딩을 하다보면 아직은 타입을 정하기 전인 상황이거나, 도저히 타입을 알 수 없거나 추론할 수 없을 때, (또는 typescript 초급자일 때 ;;) 가끔 사용하게 되는 것이 또 any 타입이다. 하지만 이제부터 이럴때 any보다는 **unknown을 사용하자. ** 이 둘의 정의는 마치 undefined와 null의 관계와도 비슷하다. (코딩을 처음 하는 경우) 얼핏 비슷해보이지만 확실하게 다른 정의이다. any는 어떤 타입도 상관 없으며 어떤 식으로 내보내져도 상관없는, 마치 typescript의 엄격모드로부터 해방시켜주는 타입의 역할을 한다. unknown은 any와는 달리 어떤 타입인지 모르겠다는 의미이다. 즉, ‘아무거나’와 ‘아직 모름’이라고 해석하는게 더 나을까? 차이는 다음과 같다. let a: unknown = 3; let b: any = 3; let c: number = 3; const unknownTest = a + c; // ERROR - TS2365: Operator '+' cannot be applied to types 'unknown' and '3'. const anyTest = b + c; any로 지정한 변수가 다른 타입인 숫자와 연산이 가능한 반면, unknown으로 지정한 변수는 숫자와 연산이 불가능하다. 즉, unknown은 어떤 타입이라도 적용할 수 있지만, 타입이 정의내려진 다른 변수 c와 함께 적용시 c의 타입에서 타입 엄격모드가 발동하며 에러를 낸다. any의 경우에는 이러한 타입 엄격모드를 마치 꺼놓은듯 typescript의 무장을 해제시키고 코드 진행이 가능하다. 따라서 디버깅을 하며 파일의 오류나 코드 흐름을 쫓을때, any보다는 unknown을 사용하는 것이 타입흐름의 통제에 있어 훨씬 낫다는 판단이 든다. ","date":"2023-01-28","objectID":"/posts/230128-typescript-any%EC%99%80-unknown%EC%9D%98-%EC%B0%A8%EC%9D%B4/:0:0","tags":["TypeScript"],"title":"typescript - any와 unknown의 차이","uri":"/posts/230128-typescript-any%EC%99%80-unknown%EC%9D%98-%EC%B0%A8%EC%9D%B4/"},{"categories":["JavaScript"],"content":"tag : #typescript related link satisfies-operator / typescript typescript 4.9에서 새로 나온 기능으로 satisfies 라는 연산자가 있다. 공식문서를 정말 한참을 봤는데도 잘 이해가 가지 않았는데 직접 코드를 가지고 만져보니 조금 이해가 되었다. ","date":"2023-01-28","objectID":"/posts/230128-typescript-satisfies-operator/:0:0","tags":["TypeScript"],"title":"typescript - satisfies operator 탐구","uri":"/posts/230128-typescript-satisfies-operator/"},{"categories":["JavaScript"],"content":"satisfies 적용 전 Record라는 객체의 key, value를 지정해주는 연산자를 사용하여 객체의 타입을 지정할 때, 아래 코드를 보면 value의 타입으로 string | RGB2 라는 union type으로 인해 속성에 대한 오류가 잡힌다. toUpperCase에서는 only string타입이 들어와야 하는데 union type으로 할당되어 생긴 에러로서 당연한 결과이다. type Colors = 'red' | 'green' | 'blue'; type RGB = [red: number, green: number, blue: number]; const palette: Record\u003cColors, string | RGB2\u003e = { red: [255, 0, 0], green: '#00ff00', blue: [0, 0, 255], }; const redComponent = palette.red.at(0); const greenNormalized = palette.green.toUpperCase(); // ^^^^^^^^^^^^^^ // error // \u003chtml\u003eTS2339: Property 'toUpperCase' does not exist on type 'string | RGB2'.\u003cbr/\u003eProperty 'toUpperCase' does not exist on type 'RGB2'. 마지막 코드의 palette.green.toUpperCase();에서 green부분을 호버해보면 다음과 같이 유니온 타입으 뜬다. 이런 경우를 위해 새로이 나온게 바로 satisfies 연산자인듯 싶다. ","date":"2023-01-28","objectID":"/posts/230128-typescript-satisfies-operator/:0:1","tags":["TypeScript"],"title":"typescript - satisfies operator 탐구","uri":"/posts/230128-typescript-satisfies-operator/"},{"categories":["JavaScript"],"content":"satisfies 적용 type을 똑같이 지정하고 객체에 대한 타입할당시 새 연산자를 사용하면 아래 예시와 같이 속성 연산에 있어서도 에러를 통과하게 된다. 즉, 유니온타입에서도 일부 유형을 만족한다면 해당 타입으로 추론하여 통과하게 되는듯 하다. type Colors = 'red' | 'green' | 'blue'; type RGB = [red: number, green: number, blue: number]; const palette = { red: [255, 0, 0], green: '#00ff00', blue: [0, 0, 255], } satisfies Record\u003cColors, string | RGB\u003e; const redComponent = palette.red.at(0); const greenNormalized = palette.green.toUpperCase(); // OK!! 위와 마찬가지로 palette.green.toUpperCase()에서 green부분을 호버해보면 유니온 타입이 아닌 string으로 할당되어 있음을 볼 수 있다. 객체가 아닌 경우의 유니온 타입에서도 될까 하고 몇가지 실험을 해봤는데 기본적으로 일단은 객체에서만 작동하는 듯 하다. 객체를 주로 사용하는 entities 모델에서도 잘 작동되는지 확인 후, 이상 없다면 굉장히 유용하게 쓰일 듯 싶다. ","date":"2023-01-28","objectID":"/posts/230128-typescript-satisfies-operator/:0:2","tags":["TypeScript"],"title":"typescript - satisfies operator 탐구","uri":"/posts/230128-typescript-satisfies-operator/"},{"categories":["env"],"content":"\u003c사진: unsplash\u003e tag : #terminal windows에서는 cmd에서 폴더트리가 바로 나오는것 같던데 macOS의 터미널에서는 따로 tree를 설치해야 볼 수 있다. 아래 명령어로 brew를 통해 설치 $ brew install tree ","date":"2023-01-23","objectID":"/posts/230123-mac-%ED%84%B0%EB%AF%B8%EB%84%90%EC%97%90%EC%84%9C-%ED%8F%B4%EB%8D%94%ED%8A%B8%EB%A6%AC-%EA%B5%AC%EC%A1%B0-%ED%99%95%EC%9D%B8/:0:0","tags":["terminal"],"title":"mac 터미널에서 폴더트리 구조 확인","uri":"/posts/230123-mac-%ED%84%B0%EB%AF%B8%EB%84%90%EC%97%90%EC%84%9C-%ED%8F%B4%EB%8D%94%ED%8A%B8%EB%A6%AC-%EA%B5%AC%EC%A1%B0-%ED%99%95%EC%9D%B8/"},{"categories":["env"],"content":"사용법 기본적인 사용법은 작업중인 폴더로 가서 tree 라고만 입력하면 된다. $ tree 폴더 제외 그런데 node project와 같이 node_module이라던가, dist 폴더가 있는 구조에서는 불필요하게 많은 폴더가 출력됨을 볼 수 있다. 폴더를 제외하고 싶을 땐, tree -I \u003cdiretory\u003e로 명령하면 해당 폴더를 제외하고 출력 가능하다. 예시\u003e 하나의 폴더 제외 $ tree -I node_module 예시\u003e 두 개의 폴더 제외 $ tree -I node_module -I dist 폴더만 출력 파일은 제외하고 폴더만 출력하고 싶다면 -d 를 옵션으로 사용할 수 있다. $ tree -d 파일은 제외하고 모든 폴더를 출력한다. 숨겨진 파일 출력 .env와 같은 파일처럼 .으로 시작하는 파일이나 숨겨진 파일의 경우 -a를 입력하여 출력할 수 있다. $ tree -a 실사용 예시 $ tree -I node_modules -I dist -I coverage -I .idea -I .github -I .git -I http-client -I .git -a 이렇게 입력하면 아래와 같이 볼 수 있는데 막상 적고보니 좀… 번거롭긴 하다. . ├── .env_sample ├── .eslintrc ├── .gitignore ├── .prettierrc ├── babel.config.js ├── db │ ├── erd │ │ └── erd.dbml │ └── migrations │ └── 20230117191810_table_set_up.sql ├── env │ ├── .env.dev │ ├── .env.production │ └── .env.test ├── jest.config.js ├── package-lock.json ├── package.json ├── src │ ├── app.ts │ ├── controllers │ │ └── users.controller.ts │ ├── entities │ │ ├── category.entity.ts │ │ ├── comment.entity.ts │ │ ├── estimation.entity.ts │ │ ├── feed.entity.ts │ │ ├── feedStatus.entity.ts │ │ ├── feedSymbol.entity.ts │ │ ├── feedUploadFiles.entity.ts │ │ ├── symbol.entity.ts │ │ ├── uploadFiles.entity.ts │ │ └── users.entity.ts │ ├── main.ts │ ├── middleware │ │ └── jwt.strategy.ts │ ├── models │ │ ├── index.ts │ │ ├── repositories.ts │ │ └── users.dao.ts │ ├── routes │ │ ├── index.route.ts │ │ └── users.route.ts │ ├── services │ │ └── users.service.ts │ ├── tests │ │ ├── setup-tests.ts │ │ └── users.test.ts │ ├── types │ │ └── global.d.ts │ └── utils │ └── util.ts └── tsconfig.json ","date":"2023-01-23","objectID":"/posts/230123-mac-%ED%84%B0%EB%AF%B8%EB%84%90%EC%97%90%EC%84%9C-%ED%8F%B4%EB%8D%94%ED%8A%B8%EB%A6%AC-%EA%B5%AC%EC%A1%B0-%ED%99%95%EC%9D%B8/:0:1","tags":["terminal"],"title":"mac 터미널에서 폴더트리 구조 확인","uri":"/posts/230123-mac-%ED%84%B0%EB%AF%B8%EB%84%90%EC%97%90%EC%84%9C-%ED%8F%B4%EB%8D%94%ED%8A%B8%EB%A6%AC-%EA%B5%AC%EC%A1%B0-%ED%99%95%EC%9D%B8/"},{"categories":["env"],"content":"tree options usage: tree [-acdfghilnpqrstuvxACDFJQNSUX] [-L level [-R]] [-H baseHREF] [-T title] [-o filename] [-P pattern] [-I pattern] [--gitignore] [--gitfile[=]file] [--matchdirs] [--metafirst] [--ignore-case] [--nolinks] [--hintro[=]file] [--houtro[=]file] [--inodes] [--device] [--sort[=]\u003cname\u003e] [--dirsfirst] [--filesfirst] [--filelimit #] [--si] [--du] [--prune] [--charset[=]X] [--timefmt[=]format] [--fromfile] [--fflinks] [--info] [--infofile[=]file] [--noreport] [--version] [--help] [--] [directory ...] ------- Listing options ------- -a All files are listed. -d List directories only. -l Follow symbolic links like directories. -f Print the full path prefix for each file. -x Stay on current filesystem only. -L level Descend only level directories deep. -R Rerun tree when max dir level reached. -P pattern List only those files that match the pattern given. -I pattern Do not list files that match the given pattern. --gitignore Filter by using .gitignore files. --gitfile X Explicitly read gitignore file. --ignore-case Ignore case when pattern matching. --matchdirs Include directory names in -P pattern matching. --metafirst Print meta-data at the beginning of each line. --prune Prune empty directories from the output. --info Print information about files found in .info files. --infofile X Explicitly read info file. --noreport Turn off file/directory count at end of tree listing. --charset X Use charset X for terminal/HTML and indentation line output. --filelimit # Do not descend dirs with more than # files in them. -o filename Output to file instead of stdout. ------- File options ------- -q Print non-printable characters as '?'. -N Print non-printable characters as is. -Q Quote filenames with double quotes. -p Print the protections for each file. -u Displays file owner or UID number. -g Displays file group owner or GID number. -s Print the size in bytes of each file. -h Print the size in a more human readable way. --si Like -h, but use in SI units (powers of 1000). --du Compute size of directories by their contents. -D Print the date of last modification or (-c) status change. --timefmt \u003cf\u003e Print and format time according to the format \u003cf\u003e. -F Appends '/', '=', '*', '@', '|' or '\u003e' as per ls -F. --inodes Print inode number of each file. --device Print device ID number to which each file belongs. ------- Sorting options ------- -v Sort files alphanumerically by version. -t Sort files by last modification time. -c Sort files by last status change time. -U Leave files unsorted. -r Reverse the order of the sort. --dirsfirst List directories before files (-U disables). --filesfirst List files before directories (-U disables). --sort X Select sort: name,version,size,mtime,ctime. ------- Graphics options ------- -i Do not print indentation lines. -A Print ANSI lines graphic indentation lines. -S Print with CP437 (console) graphics indentation lines. -n Turn colorization off always (-C overrides). -C Turn colorization on always. ------- XML/HTML/JSON options ------- -X Prints out an XML representation of the tree. -J Prints out an JSON representation of the tree. -H baseHREF Prints out HTML format with baseHREF as top directory. -T string Replace the default HTML title and H1 header with string. --nolinks Turn off hyperlinks in HTML output. --hintro X Use file X as the HTML intro. --houtro X Use file X as the HTML outro. ------- Input options ------- --fromfile Reads paths from files (.=stdin) --fflinks Process link informtion when using --fromfile. ------- Miscellaneous options ------- --version Print version and exit. --help Print usage and this help message and exit. -- Options processing terminator. ","date":"2023-01-23","objectID":"/posts/230123-mac-%ED%84%B0%EB%AF%B8%EB%84%90%EC%97%90%EC%84%9C-%ED%8F%B4%EB%8D%94%ED%8A%B8%EB%A6%AC-%EA%B5%AC%EC%A1%B0-%ED%99%95%EC%9D%B8/:0:2","tags":["terminal"],"title":"mac 터미널에서 폴더트리 구조 확인","uri":"/posts/230123-mac-%ED%84%B0%EB%AF%B8%EB%84%90%EC%97%90%EC%84%9C-%ED%8F%B4%EB%8D%94%ED%8A%B8%EB%A6%AC-%EA%B5%AC%EC%A1%B0-%ED%99%95%EC%9D%B8/"},{"categories":["Node.js"],"content":"tag : #typescript #express {{TOC}} ","date":"2023-01-23","objectID":"/posts/230123-%EB%B0%B1%EC%97%94%EB%93%9C-typescript-express-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-jest-%EB%B0%8F-node-%ED%99%98%EA%B2%BD%EC%97%90-%EB%94%B0%EB%9D%BC-dotenv-%EC%84%A4%EC%A0%95-%EB%B6%84%EB%A6%AC/:0:0","tags":["TypeScript","Express"],"title":"백엔드 - typescript-express 환경에서 jest 및 node 환경에 따라 dotenv 설정 분리","uri":"/posts/230123-%EB%B0%B1%EC%97%94%EB%93%9C-typescript-express-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-jest-%EB%B0%8F-node-%ED%99%98%EA%B2%BD%EC%97%90-%EB%94%B0%EB%9D%BC-dotenv-%EC%84%A4%EC%A0%95-%EB%B6%84%EB%A6%AC/"},{"categories":["Node.js"],"content":"문제상황 TDD 방법론을 따라 프로젝트를 진행하려는데 Jest를 이용하여 test 코드를 작성하던 중, 한가지 문제를 마주한다. test를 위한 DB는 그 조건에 따라 생성되고 삭제되어지는 특성상, 실제 개발환경에서의 DB와 test DB를 분리하기 위해서 local DB는 2가지로 나누어 세팅을 해야한다. 그런데 test를 실행할때마다 typeORM 세팅의 연결값을 매번 변경해줘야하는 문제가 상당히 번거로웠다. 고민하던 와중, cross-env라는 npm package를 알게되었고 이를 이용하여 상황에 따라 dotenv 설정값을 유동적으로 활용할 수 있도록 세팅을 구상해보았다. 요약. JEST의 test파일 실행시 기존 DB를 사용함으로 인한 DB내부 데이터 오염문제 test용 DB 분리로 해결 test용 DB 분리 이후, npm run 실행 환경(dev, test, production)에 따른 DB 설정문제 개발간 서버를 돌릴때, test코드를 돌릴때마다 dev.DB와 test.DB를 따로이 설정해줘야 하는 번거로움 main.ts파일에서 cross-env 패키지를 사용하더라도 JEST- test 코드는 해당 파일을 사용하지 않기에 어떻게 환경설정을 분리시킬 수 있는가에 따른 고민 ","date":"2023-01-23","objectID":"/posts/230123-%EB%B0%B1%EC%97%94%EB%93%9C-typescript-express-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-jest-%EB%B0%8F-node-%ED%99%98%EA%B2%BD%EC%97%90-%EB%94%B0%EB%9D%BC-dotenv-%EC%84%A4%EC%A0%95-%EB%B6%84%EB%A6%AC/:1:0","tags":["TypeScript","Express"],"title":"백엔드 - typescript-express 환경에서 jest 및 node 환경에 따라 dotenv 설정 분리","uri":"/posts/230123-%EB%B0%B1%EC%97%94%EB%93%9C-typescript-express-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-jest-%EB%B0%8F-node-%ED%99%98%EA%B2%BD%EC%97%90-%EB%94%B0%EB%9D%BC-dotenv-%EC%84%A4%EC%A0%95-%EB%B6%84%EB%A6%AC/"},{"categories":["Node.js"],"content":"Project Tree 우선 현재 상황에서의 project folder Tree는 다음과 같다. // project Tree ├── .env ├── jest.config.js ├── package.json ├── src │ ├── app.ts │ ├── controllers │ │ └── users.controller.ts │ ├── entities │ │ └── users.entity.ts │ ├── main.ts │ ├── middleware │ │ └── jwt.strategy.ts │ ├── models │ │ ├── index.ts │ │ ├── repositories.ts │ │ └── users.dao.ts │ ├── routes │ │ ├── index.route.ts │ │ └── users.route.ts │ ├── services │ │ └── users.service.ts │ ├── tests │ │ ├── setup-tests.ts │ │ └── users.test.ts │ ├── types │ │ └── global.d.ts │ └── utils │ └── util.ts └── tsconfig.json ","date":"2023-01-23","objectID":"/posts/230123-%EB%B0%B1%EC%97%94%EB%93%9C-typescript-express-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-jest-%EB%B0%8F-node-%ED%99%98%EA%B2%BD%EC%97%90-%EB%94%B0%EB%9D%BC-dotenv-%EC%84%A4%EC%A0%95-%EB%B6%84%EB%A6%AC/:1:1","tags":["TypeScript","Express"],"title":"백엔드 - typescript-express 환경에서 jest 및 node 환경에 따라 dotenv 설정 분리","uri":"/posts/230123-%EB%B0%B1%EC%97%94%EB%93%9C-typescript-express-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-jest-%EB%B0%8F-node-%ED%99%98%EA%B2%BD%EC%97%90-%EB%94%B0%EB%9D%BC-dotenv-%EC%84%A4%EC%A0%95-%EB%B6%84%EB%A6%AC/"},{"categories":["Node.js"],"content":"설정 고민하며 생각했던 해결방안\u001f 다음과 같다. 일반적인 개발환경과 test를 위한 환경을 구분할 수 있는 특정값을 조건으로 할당 위에서 할당한 조건에 따라 node는 각기 다른 dotenv 파일을 참조하여 실행할 수 있도록 작성 우선 1번을 구현하기 위해 cross-env 패키지를 이용하여 조건을 할당한다. ","date":"2023-01-23","objectID":"/posts/230123-%EB%B0%B1%EC%97%94%EB%93%9C-typescript-express-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-jest-%EB%B0%8F-node-%ED%99%98%EA%B2%BD%EC%97%90-%EB%94%B0%EB%9D%BC-dotenv-%EC%84%A4%EC%A0%95-%EB%B6%84%EB%A6%AC/:2:0","tags":["TypeScript","Express"],"title":"백엔드 - typescript-express 환경에서 jest 및 node 환경에 따라 dotenv 설정 분리","uri":"/posts/230123-%EB%B0%B1%EC%97%94%EB%93%9C-typescript-express-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-jest-%EB%B0%8F-node-%ED%99%98%EA%B2%BD%EC%97%90-%EB%94%B0%EB%9D%BC-dotenv-%EC%84%A4%EC%A0%95-%EB%B6%84%EB%A6%AC/"},{"categories":["Node.js"],"content":"cross-env package 설치 $ npm i -D dotenv cross-env [!tip] npm 설치 명령 중 i는 install의 약어 -D는 --dev 의 약어 개발환경에서 사용할 예정이라 devDependency에 설치해준다. cli에서 명령어 입력시 정확한 입력에 주의한다. [!warning] crossenv 사건 1 노드와 npm 생태계를 떠들썩하게 만든 사건이 있었다. 이름하여 ‘crossenv 사건’ 이다. 사람들이 cross-env를 설치할 때 실수로 cross-env 대신 crossenv를 설치해서 발생했는데, crossenv는 사용자의 .env 파일에 들어 있는 키들을 해커에게 전송하는 악성 패키지였던 것이었다. 다행히 문제를 발견한 즉시 패키지가 차단되어 피해가 크게 확산되지는 않았지만, 유명한 패키지를 설치하는 과정에 혼동을 야기해 해킹하려는 시도가 있었다는 점에서 충격적인 사건이었다. 따라서 패키지를 설치할 때는 항상 주의를 기울여야 한다. ","date":"2023-01-23","objectID":"/posts/230123-%EB%B0%B1%EC%97%94%EB%93%9C-typescript-express-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-jest-%EB%B0%8F-node-%ED%99%98%EA%B2%BD%EC%97%90-%EB%94%B0%EB%9D%BC-dotenv-%EC%84%A4%EC%A0%95-%EB%B6%84%EB%A6%AC/:2:1","tags":["TypeScript","Express"],"title":"백엔드 - typescript-express 환경에서 jest 및 node 환경에 따라 dotenv 설정 분리","uri":"/posts/230123-%EB%B0%B1%EC%97%94%EB%93%9C-typescript-express-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-jest-%EB%B0%8F-node-%ED%99%98%EA%B2%BD%EC%97%90-%EB%94%B0%EB%9D%BC-dotenv-%EC%84%A4%EC%A0%95-%EB%B6%84%EB%A6%AC/"},{"categories":["Node.js"],"content":"node setting package.json 파일에서 명령어를 이용해 앞서 설치하였던 cross-env 패키지에서 사용할 NODE_ENV라는 이름으로 설정값을 세팅한다. (이름은 다른걸로 해도 무방하다.) // package.json \"scripts\": { \"test\": \"cross-env NODE_ENV=test jest --runInBand --detectOpenHandles --forceExit\", \"start\": \"cross-env NODE_ENV=production node dist/main.js\", \"dev\": \"cross-env NODE_ENV=develop concurrently \\\"npx tsc --watch\\\" \\\"nodemon -q dist/main.js\\\"\", npm 명령 스크립트의 서두에 cross-env NODE_ENV=\u003cKEY\u003e 라는 방식으로 세팅을 해두면, 해당 명령이 실행될때 NODE_ENV 의 값이 앞서 언급한 조건으로서 process.env.NODE_ENV라는 dotenv의 내부 값으로 할당된다. 예시\u003e $ npm test # NODE_ENV=test 라는 값으로 세팅되고 jest가 실행된다. $ npm run dev # NODE_ENV=dev 라는 값으로 세팅되고 ts파일의 컴파일과 nodemon이 실행된다. 이렇게 스크립트단에서의 명령어에 세팅을 해두고 이제 해당 값에 따라 dotenv가 적용될 수 있게끔, 설정파일의 분리를 진행한다. ","date":"2023-01-23","objectID":"/posts/230123-%EB%B0%B1%EC%97%94%EB%93%9C-typescript-express-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-jest-%EB%B0%8F-node-%ED%99%98%EA%B2%BD%EC%97%90-%EB%94%B0%EB%9D%BC-dotenv-%EC%84%A4%EC%A0%95-%EB%B6%84%EB%A6%AC/:2:2","tags":["TypeScript","Express"],"title":"백엔드 - typescript-express 환경에서 jest 및 node 환경에 따라 dotenv 설정 분리","uri":"/posts/230123-%EB%B0%B1%EC%97%94%EB%93%9C-typescript-express-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-jest-%EB%B0%8F-node-%ED%99%98%EA%B2%BD%EC%97%90-%EB%94%B0%EB%9D%BC-dotenv-%EC%84%A4%EC%A0%95-%EB%B6%84%EB%A6%AC/"},{"categories":["Node.js"],"content":"dotenv 분리 우선 상황에 따른 dotenv 설정값을 별도로 작성한 파일을 만들어주는데, root 폴더에서 파일을 그대로 두자니 지저분한것 같아 따로이 폴더를 만들어 그 안에 정리하였다. ├── env ├── .env.dev ├── .env.production └── .env.test typrORM의 dotenv 설정을 아래 예시로 들어본다. 차이점은, TYPEORM_DATABASE명에서 test용과 개발용을 구분하였고, TYPEORM_LOGGING의 경우 test환경에서는 필요가 없기에 false로 처리하였다. 그리고 배포시에 쓰는 .env.production 파일에서는 연결시마다 scheme 자동생성을 막기 위해 TYPEORM_SYNCHRONIZE=FALSE 처리를 해둔다. 예시\u003e // env/.env.dev #typeorm TYPEORM_CONNECTION=mysql TYPEORM_HOST=127.0.0.1 TYPEORM_USERNAME=root TYPEORM_PASSWORD=1234\" TYPEORM_DATABASE=project_abc // \u003c- 여기 TYPEORM_PORT=3306 TYPEORM_LOGGING=TRUE // \u003c- 여기 TYPEORM_SYNCHRONIZE=TRUE // env/.env.test TYPEORM_CONNECTION=mysql TYPEORM_HOST=127.0.0.1 TYPEORM_USERNAME=root TYPEORM_PASSWORD=1234 TYPEORM_DATABASE=test_project_abc // \u003c- 여기 TYPEORM_PORT=3306 TYPEORM_LOGGING=FALSE // \u003c- 여기 TYPEORM_SYNCHRONIZE=TRUE 그리고 끝으로 이제 앞에서 특정한 값을 실행시킬 수 있도록 express를 실행하는 파일(대개 main.ts)에서 아래와 같이 세팅을 한다. 2 // src/main.ts import dotenv from 'dotenv'; import path from 'path'; if (process.env.NODE_ENV === 'production') { dotenv.config({ path: path.join(__dirname, '/../env/.env.production') }); } else if (process.env.NODE_ENV === 'develop') { dotenv.config({ path: path.join(__dirname, '/../env/.env.dev') }); console.log('process.env.NODE_ENV is ', process.env.NODE_ENV); } else if (process.env.NODE_ENV === 'test') { dotenv.config({ path: path.join(__dirname, '/../env/.env.test') }); } else { throw new Error('process.env.NODE_ENV IS_NOT_SET!!'); } console.log('process.env.NODE_ENV is ', process.env.NODE_ENV); dev 설정시 따로 console.log를 찍어준 이유는 개발환경에서 dev설정이 제대로 먹히고 있는지 확인차 넣어줬다. 3 ","date":"2023-01-23","objectID":"/posts/230123-%EB%B0%B1%EC%97%94%EB%93%9C-typescript-express-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-jest-%EB%B0%8F-node-%ED%99%98%EA%B2%BD%EC%97%90-%EB%94%B0%EB%9D%BC-dotenv-%EC%84%A4%EC%A0%95-%EB%B6%84%EB%A6%AC/:2:3","tags":["TypeScript","Express"],"title":"백엔드 - typescript-express 환경에서 jest 및 node 환경에 따라 dotenv 설정 분리","uri":"/posts/230123-%EB%B0%B1%EC%97%94%EB%93%9C-typescript-express-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-jest-%EB%B0%8F-node-%ED%99%98%EA%B2%BD%EC%97%90-%EB%94%B0%EB%9D%BC-dotenv-%EC%84%A4%EC%A0%95-%EB%B6%84%EB%A6%AC/"},{"categories":["Node.js"],"content":"jest 세팅 exress를 돌릴때, 만약 app.ts와 main.ts(or index.ts)등으로 나누어 놓았다면, process.env.NODE_ENV 는 main.ts에 작성되기에 jest에서는 해당 설정이 적용되지 않는다. 때문에 test 파일 실행시 test용 dotenv가 작동될 수 있도록 따로 세팅을 해주어야 한다.(파일명 확인) // 최상단 root폴더에 jest.config.js 또는 jest.config.json 파일 setupFiles: [ '\u003croot\u003e/src/tests/setup-tests.ts', ], // setup-tests.ts (파일명은 jest.config에서 설정했던 값과 동일하기만 하면 되기에 임의로 정해도 된다.) import dotenv from 'dotenv'; dotenv.config({ path: '\u003croot\u003e/env/.env.test', }); 위에서 설명한 바와 같이 세팅을 하면, 이제 jest / test파일 실행시 해당 dotenv 설정이 작동한다. typeORM.intialize()를 사용한다면 여기에 더해 실행하고자 하는 test파일 내부에서 한가지 더 코드가 필요하다. // users.test.ts const dataSource = new DataSource({ type: process.env.TYPEORM_CONNECTION, host: process.env.TYPEORM_HOST, port: process.env.TYPEORM_PORT, username: process.env.TYPEORM_USERNAME, password: process.env.TYPEORM_PASSWORD, database: process.env.TYPEORM_DATABASE, entities: [__dirname + '/../**/*.entity.{js,ts}'], logging: process.env.TYPEORM_LOGGING, synchronize: process.env.TYPEORM_SYNCHRONIZE, }); jest에서는 코드가 돌아갈때, main.ts파일을 거치지 않기때문에 typeorm의 DataSource 코드가 돌기 전 이니셜라이징할 수 있도록 따로 준비가 필요하다. 위와 같이 설정시, 앞서 설정했던 jest.config에 따라 intialize() 코드가 돌게되고 이후부터는 앞서 설명했던대로 함수와 명령들이 실행되게 된다. ","date":"2023-01-23","objectID":"/posts/230123-%EB%B0%B1%EC%97%94%EB%93%9C-typescript-express-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-jest-%EB%B0%8F-node-%ED%99%98%EA%B2%BD%EC%97%90-%EB%94%B0%EB%9D%BC-dotenv-%EC%84%A4%EC%A0%95-%EB%B6%84%EB%A6%AC/:2:4","tags":["TypeScript","Express"],"title":"백엔드 - typescript-express 환경에서 jest 및 node 환경에 따라 dotenv 설정 분리","uri":"/posts/230123-%EB%B0%B1%EC%97%94%EB%93%9C-typescript-express-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-jest-%EB%B0%8F-node-%ED%99%98%EA%B2%BD%EC%97%90-%EB%94%B0%EB%9D%BC-dotenv-%EC%84%A4%EC%A0%95-%EB%B6%84%EB%A6%AC/"},{"categories":["Node.js"],"content":"추가 : dotenv 분리로 morgan설정 역시 따로 분리 가능 //app.ts const createApp = () =\u003e { const app: Express = express(); app.use(cors(corsOptions)); if (process.env.NODE_ENV === 'develop') { app.use(morgan('dev')); // \u003c- 이렇게 } else { app.use(morgan('combined')); // \u003c- 이렇게 } app.use(express.json()); app.use(express.urlencoded({ extended: false })); app.use(router); return app; }; express에서 log를 남겨주는 morgan의 옵션중 dev와 combined 가 있는데 이를 상황에 맞게 나눌 수 있다. [!tip] dev 4 개발용을 위해 response에 따라 색상이 입혀진 축약된 로그를 출력. status값이 빨간색이면 서버 에러코드, 노란색이면 클라이언트 에러 코드, 청록색은 리다이렉션 코드, 그외 코드는 컬러가 없다. combined 배포환경에서 사용 불특정 다수가 접속하기 때문에 IP를 로그에 남겨줌 NODE 📚 cross-env 모듈 사용법 ↩︎ Nest.js - Deprecated - dotenv 와 cross-env 를 활용한 환경 별 환경 변수 지정하기 ↩︎ 그리고 끝까지 본문을 읽으면 알겠지만 test용 dotenv설정은 따로이 jest세팅에서 진행하기에 사실, else if (process.env.NODE_ENV === 'test') { dotenv.config({ path: path.join(__dirname, '/../env/.env.test') }); 이 부분은 필요가 없다. 하지만 추후 다른 용도에서 응용을 위한 예시로써 남겨둔다. ↩︎ EXPRESS morgan 미들웨어 사용법 정리 ↩︎ ","date":"2023-01-23","objectID":"/posts/230123-%EB%B0%B1%EC%97%94%EB%93%9C-typescript-express-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-jest-%EB%B0%8F-node-%ED%99%98%EA%B2%BD%EC%97%90-%EB%94%B0%EB%9D%BC-dotenv-%EC%84%A4%EC%A0%95-%EB%B6%84%EB%A6%AC/:3:0","tags":["TypeScript","Express"],"title":"백엔드 - typescript-express 환경에서 jest 및 node 환경에 따라 dotenv 설정 분리","uri":"/posts/230123-%EB%B0%B1%EC%97%94%EB%93%9C-typescript-express-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-jest-%EB%B0%8F-node-%ED%99%98%EA%B2%BD%EC%97%90-%EB%94%B0%EB%9D%BC-dotenv-%EC%84%A4%EC%A0%95-%EB%B6%84%EB%A6%AC/"},{"categories":["Error Note"],"content":"tag : #JavaScript ","date":"2023-01-18","objectID":"/posts/230118-error-note-throw%EC%99%80-return/:0:0","tags":["JavaScript"],"title":"error note - throw와 return","uri":"/posts/230118-error-note-throw%EC%99%80-return/"},{"categories":["Error Note"],"content":"문제상황 Failure 에러핸들링 중, 에러메세지를 response로 보내려고 한다. 이에 return을 사용 에러가 나와야 할 상황에서 정상적으로 에러메세지를 response로 보낸다. 하지만 에러코드를 알려야 할 status code는 정상을 알리며 이후 모든 함수와 명령이 진행됨 ","date":"2023-01-18","objectID":"/posts/230118-error-note-throw%EC%99%80-return/:1:0","tags":["JavaScript"],"title":"error note - throw와 return","uri":"/posts/230118-error-note-throw%EC%99%80-return/"},{"categories":["Error Note"],"content":"해결 Success return이 아닌 throw를 사용하여야 한다. 특히 node.js에서 서버를 돌릴때, 단순히 return만으로는 이후의 모든 과정, 즉 controller - service - dao 등에서 return을 한 함수 이외 모든 명령어가 진행 된다. 하지만 throw의 경우, 에러를 내보내는 것 뿐만 아니라 이후의 모든 명령어를 중지시킨다. 단순히 response창만 봤다가는 정상적으로 에러를 잡는것 같지만 실제 잘못된 데이터들이 계속해서 DB에 쌓이는걸 볼 수 있다. 문법의 기본 의미를 더 살펴보게 된다. return1 return 명령문 은 함수 실행을 종료하고, 주어진 값을 함수 호출 지점으로 반환합니다. throw2 ** throw ** 문은 사용자 정의 예외를 발생(throw)할 수 있습니다. 예외가 발생하면 현재 함수의 실행이 중지되고 (throw 이후의 명령문은 실행되지 않습니다.), 제어 흐름은 콜스택의 첫 번째 catch 블록으로 전달됩니다. 호출자 함수 사이에 catch 블록이 없으면 프로그램이 종료됩니다. 얼핏 보면 둘 다 현재 함수의 실행을 중지한다는 부분에서 유사하게 보일 수 있다. 하지만 MDN 문서 중 throw 설명의 두번째 줄. Note ** throw 이후의 명령문은 실행되지 않습니다. ** 이 부분을 다시 살펴보게 된다. return - JavaScript | MDN ↩︎ throw - JavaScript | MDN ↩︎ ","date":"2023-01-18","objectID":"/posts/230118-error-note-throw%EC%99%80-return/:2:0","tags":["JavaScript"],"title":"error note - throw와 return","uri":"/posts/230118-error-note-throw%EC%99%80-return/"},{"categories":["Error Note"],"content":"tag : #typeorm #typescript source : node.js - using process.env in TypeScript - Stack Overflow ","date":"2023-01-18","objectID":"/posts/230118-error-note-typeorm%EC%9D%84-dotenv%EB%A1%9C-%EC%97%B0%EA%B2%B0%ED%95%98%EC%97%AC-%EC%84%A4%EC%A0%95%EC%8B%9C-typescript%EC%97%90%EC%84%9C%EC%9D%98-type-error/:0:0","tags":["TypeScript"],"title":"error note - typeORM을 dotEnv로 연결하여 설정시 TypeScript에서의 type Error","uri":"/posts/230118-error-note-typeorm%EC%9D%84-dotenv%EB%A1%9C-%EC%97%B0%EA%B2%B0%ED%95%98%EC%97%AC-%EC%84%A4%EC%A0%95%EC%8B%9C-typescript%EC%97%90%EC%84%9C%EC%9D%98-type-error/"},{"categories":["Error Note"],"content":"에러 상황 TypeScript로 typeORM을 세팅할때, dotEnv로 설정값을 주고 연결을 해보면 다음과 같은 오류를 볼 수 있다. 위 3개의 해당 error message를 살펴보면 차례로 다음과 같다. TS2322: Type 'string' is not assignable to type '\"mysql\" | \"mariadb\" | \"postgres\" | \"cockroachdb\" | \"sqlite\" | \"mssql\" | \"sap\" | \"oracle\" | \"cordova\" | \"nativescript\" | \"react-native\" | \"sqljs\" | \"mongodb\" | \"aurora-mysql\" | ... 4 more ... | \"spanner\"'. TS2322: Type 'string' is not assignable to type 'number'. TS2322: Type 'string' is not assignable to type 'LoggerOptions'. 이는 typeORM의 설정 type이 정해져있어서 그렇다. 첫번째, type의 경우 mysql' | 'mariadb' | 'postgres'... 의 경우로 type이 정해져있음을 볼 수 있다. 즉 이를 지정해주면 되는데, 조금 난해하다. ","date":"2023-01-18","objectID":"/posts/230118-error-note-typeorm%EC%9D%84-dotenv%EB%A1%9C-%EC%97%B0%EA%B2%B0%ED%95%98%EC%97%AC-%EC%84%A4%EC%A0%95%EC%8B%9C-typescript%EC%97%90%EC%84%9C%EC%9D%98-type-error/:1:0","tags":["TypeScript"],"title":"error note - typeORM을 dotEnv로 연결하여 설정시 TypeScript에서의 type Error","uri":"/posts/230118-error-note-typeorm%EC%9D%84-dotenv%EB%A1%9C-%EC%97%B0%EA%B2%B0%ED%95%98%EC%97%AC-%EC%84%A4%EC%A0%95%EC%8B%9C-typescript%EC%97%90%EC%84%9C%EC%9D%98-type-error/"},{"categories":["Error Note"],"content":"해결 global.d.ts라는 이름의 파일을 만들고 1 다음과 같이 세팅을 한다. declare global { namespace NodeJS { interface ProcessEnv { TYPEORM_CONNECTION: 'mysql' | 'mariadb'; TYPEORM_PORT: number; SECRET_KEY: string; TYPEORM_LOGGING: boolean; } } } export {} // \u003c- 이거 꼭 넣어줘야 한다. global로 선언하고, NodeJS에서의 dotenv 명은 ProcessEnv인가보다. 문제는 이렇게 해도 타입에러가 해결되지 않는다. 이는 밖으로 내보내기가 되지 않아서 생긴 문제로, 아무 의미 없는것 같지만 export {} 를 가장 아랫단에 꼭 넣어줘야 한다. Note 다른 파일에서 타입 정의시, declare - namespace 후, export {} 넣기!! 그러면 정상적으로 에러가 해결됨을 볼 수 있다. 중괄호 안에 아무것도 없지만 정확하게 어떻게 작동하는지는 조금 더 공부를 해봐야겠다. 파일명은 상관없다. ↩︎ ","date":"2023-01-18","objectID":"/posts/230118-error-note-typeorm%EC%9D%84-dotenv%EB%A1%9C-%EC%97%B0%EA%B2%B0%ED%95%98%EC%97%AC-%EC%84%A4%EC%A0%95%EC%8B%9C-typescript%EC%97%90%EC%84%9C%EC%9D%98-type-error/:2:0","tags":["TypeScript"],"title":"error note - typeORM을 dotEnv로 연결하여 설정시 TypeScript에서의 type Error","uri":"/posts/230118-error-note-typeorm%EC%9D%84-dotenv%EB%A1%9C-%EC%97%B0%EA%B2%B0%ED%95%98%EC%97%AC-%EC%84%A4%EC%A0%95%EC%8B%9C-typescript%EC%97%90%EC%84%9C%EC%9D%98-type-error/"},{"categories":["Node.js"],"content":"tag : #nestjs #typescript #JavaScript source : 따라하면서 배우는 NestJS - YouTube ","date":"2023-01-09","objectID":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/:0:0","tags":["NestJS"],"title":"nestJS 시작하기","uri":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"nestJS - cli 설치 사전 조건 : node lts버전 설치 npm i @nestjs/cli 또는 npm i -g @nestjs/cli 이렇게 package.json 파일에서 정상적으로 설치되었음을 확인할 수 있다. ","date":"2023-01-09","objectID":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/:1:0","tags":["NestJS"],"title":"nestJS 시작하기","uri":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"nestJS - new Project 시작하기 nest new \u003cnew project name\u003e // 예시 nest new nestjs-test 위와 같이 입력하면 현재 터미널이 위치한 폴더 내에 새로운 “nestjs-test\"폴더가 만들어지면서 그 안에 세팅이 된다. 만약 $ mkdir nestjs-test 로 폴더를 만들고 이 위치에서 진행중이라면, nest new ./ 위와 같이 입력시 현재 폴더명 그대로 새로운 프로젝트가 진행된다. 계속해서 진행시 아래와 같은 선택을 묻는다. npm 또는 yarn 등, 편한 패키지로 선택하면 nestJS 기본 세팅이 이루어진다. 위 이미지와 같이 prettier부터 controller-service-model, main.ts, jest 등 기본적인 구성이 모두 세팅된다. (시간이 조금 걸릴 수 있다.) ","date":"2023-01-09","objectID":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/:2:0","tags":["NestJS"],"title":"nestJS 시작하기","uri":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"모듈 생성 nestJS에서는 nest 명령어로 모듈을 생성할 수 있다. nest g module boards 설명 nest : nest cli 사용 g : generate module : schematic that I want to create boards : name of schematic ","date":"2023-01-09","objectID":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/:3:0","tags":["NestJS"],"title":"nestJS 시작하기","uri":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"controller, service 생성하기 nest g controller boards --no-spec nest g service boards --no-spec 한줄씩 차례로 입력하면 된다. 설명 nest : using nest cli g : generate controller : controller schematic service : service schematic boards: name of the schematic –no-spec: 테스트를 위한 소스코드 생성을 하지 않겠다! [!tip] 접근제한자를 이용해서 소스 간단하게하기 접근제한자(public,protected,private)을 생성자(constructor) 파라미터에 선언하면 접근제한자가 사용된 생성자파라미터는 암묵적으로 클래스 프로퍼티로 선언된다. ","date":"2023-01-09","objectID":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/:3:1","tags":["NestJS"],"title":"nestJS 시작하기","uri":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"NestJS에서 request의 body값은 어떻게 가져올까? NodeJS에서는 req.body로 가져올 수 있다. app.post(`/`, (req,res) =\u003e { console.log(req.body); }) 하지만 NestJS에서는 @Body body를 이용해서 가져온다. 이렇게 하면 모든 request에서 보내온 값을 가져올 수 있으며, 만약, 하나씩 가져오려면 @Body('title') title 혹은 @Body('description') description 이런식으로 가져올 수 있다. @Post() createBoard(@Body() body) { console.log('body', body); } @Post() createBoard(@Body('title') title: string, @Body('description'), description: string, ) { console.log('title', title); console.log('description', description); } ","date":"2023-01-09","objectID":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/:4:0","tags":["NestJS"],"title":"nestJS 시작하기","uri":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"NestJS에서 Param은 어떻게 가져올까? localhost:3000/:id 와 같은 params 값의 경우, body와 유사하다. 위의 경우에는 findOne(@Param('id') id: string) 과 같이 가져오면 된다. 만약 여러개의 Param을 가져와야 한다면, findOne(@Param() params: string[]) 으로 가져올 수 있다. \\ Note @는 데코레이터라고 부른다. 타입스크립트의 데코레이터는 파이썬의 데코레이터나 자바의 어노테이션과 유사한 기능을 한다. 클래스, 메서드, 접근자, 프로퍼티, 매개변수에 적용 가능 참고 - 2.6 데코레이터 - NestJS로 배우는 백엔드 프로그래밍 ","date":"2023-01-09","objectID":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/:4:1","tags":["NestJS"],"title":"nestJS 시작하기","uri":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"DTO (Data Transfer Object)란? 계층간 데이터 교환을 위한 객체 DB에서 데이터를 얻어 Service나 Controller 등으로 보낼 때 사용하는 객체를 말한다. DTO는 데이터가 네트워크를 통해 전송되는 방법을 정의하는 객체이다. NestJS 공식문서에서는 interface보다는 class를 이용해서 정의하는 것을 추천하고 있다. DTO(Data Transfer Object)를 쓰는 이유는? 데이터 유효성을 체크하는데 효율적 더 안정적인 코드로 만들어준다. 타입스크립트의 타입으로도 사용된다. 예시) controller, service에서 인자로 title, description이 있는 상황에서 만약 title을 다른 인자로 바꾼다면? 인자가 하나인 경우에는 크게 문제가 없겠지만 이것들이 여러개라면 모든 파일에서 인자를 다 수정해줘야 한다. 하지만 DTO를 이용한다면 이 모든 것을 하나의 class로 처리하고 해당 class만 수정하면 된다. ","date":"2023-01-09","objectID":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/:5:0","tags":["NestJS"],"title":"nestJS 시작하기","uri":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"Pipe란?? 파이프는 @Injectable() 데코레이터로 주석이 달린 클래스이다. 파이프는 data transformation (데이터 변형)과 data validation (데이터 유효성)을 위해서 사용된다. 파이프는 컨트롤러 경로 처리기에 의해 처리되는 인수에 대해 작동한다. Nest는 메소드가 호출되기 직전에 파이프를 삽입하고 파이트는 메소드로 향하는 인수를 수신하고 이에 대해 작동한다. Data Transformation? 입력 데이터를 원하는 형식으로 변환 (예 : 문자열을 정수로) PIPE 사용하는 법 (Binding Pipes) Handler-level Pipes Parameter-level pipes Golbal-level Pipes Built-in PIpes NestJS에서 기본적으로 사용할 수 있는 6가지 파이프 ValidationPipe ParseIntPipe ParseBoolPipe ParseArrayPipe ParseUUIDPipe DefaultValuesPipe ","date":"2023-01-09","objectID":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/:5:1","tags":["NestJS"],"title":"nestJS 시작하기","uri":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"파이프를 이용한 유효성 체크 검사 필요한 모듈 class-validator, class-transformer npm install class-validator class-transformer --save Documentation page 예시 create-board.dto.ts 파일에서 import { IsNotEmpty } from 'class-validator'; export class CreateBoardDto { @IsNotEmpty() // \u003c-- 이렇게 title: string; @IsNotEmpty() // \u003c-- 이렇게 description: string; } 먼저 위와 같이 각 인자별로 반드시 있어야 하는 곳에 @IsNotEmpty를 적용시킨다. controller 파일에서 @Post() @UsePipes(ValidationPipe) // \u003c-- 이렇게 createBoard(@Body() createBoardDto: CreateBoardDto): Board { return this.boardsService.createBoard(createBoardDto); } 다음으로 위와 같이 해당 부분에 @UsePipes(ValidationPipe)를 적용시킨다. 위 방법은 앞서 언급했던 3가지 Binding Pipes 중, Handler-level Pipes이다. @IsNotEmpty를 적용하지 않았을 경우 실제 Postman을 돌려보면 UsePipes에서 해당 함수를 찾을 수 없다는 오류가 뜨며, @UsePipes를 적용하지 않았을 경우에는 해당 유효성 검사 자체가 이루어지지 않는다. ","date":"2023-01-09","objectID":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/:5:2","tags":["NestJS"],"title":"nestJS 시작하기","uri":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"에러를 표출해주기 위해서는 예를 들어 찾는 게시물이 없는 경우, 예외 인스턴스를 생성해서 이용할 수 있다. getBoardById(id: string): Board { const found = this.boards.find(board =\u003e board.id === id); if(!found) { throw new NotFoundException() } return found; } NotFoundException은 nestjs에 있는 인스턴스이다. (import로 사용가능) 사용시 다음과 같은 에러메세지를 볼 수 있다. { \"statusCode\": 404, \"message\": \"Not Found\" } 여기서 만약 에러메세지를 따로 넣어주고 싶다면, getBoardById(id: string): Board { const found = this.boards.find(board =\u003e board.id === id); if(!found) { throw new NotFoundException(`Can't find Board with id ${id}`) } return found; } 이렇게 하면, 아래와 같이 response 된다. { \"statusCode\": 404, \"message\": \"Can't find Board with id wefewwefewf\", \"error\": \"Not Found\" } ","date":"2023-01-09","objectID":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/:5:3","tags":["NestJS"],"title":"nestJS 시작하기","uri":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"커스텀 파이프 구현방법 먼저 Pipe Transform이란 인터페이스를 새롭게 만들 커스텀 파이프에 구현해줘야 한다. 이 Pipe Transform 인터페이스는 모든 파이프에서 구현해줘야 하는 인터페이스이다. 그리고 이것과 함께 모든 파이프는 transform()메소드를 필요로 한다. 이 메소드는 NestJS가 인자(arjuments)를 처리하기 위해서 사용된다. import { ArgumentMetadata, PipeTransform } from \"@nestjs/common\" export class BoardStatusValidationPipe implements PipeTransform { transfomr(value: any, metadata: ArgumentMetadata) { console.log('value', value) console.log('metadata', metadata) return value; } } transform() 메소드 이 메소드는 2 개의 파라미터를 가진다. 첫번째 파라미터는 처리가 된 인자의 값(value)이며, 두번째 파라미터는 인자에 대한 메타 데이터를 포함한 객체이다. transform()메소드에서 return된 값은 Route 핸들러로 전해진다. 만약 예외(Exception)가 발생하면 클라이언트에 바로 전해진다. ","date":"2023-01-09","objectID":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/:5:4","tags":["NestJS"],"title":"nestJS 시작하기","uri":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"mySQL 및 TypeORM ","date":"2023-01-09","objectID":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/:6:0","tags":["NestJS"],"title":"nestJS 시작하기","uri":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"설치 typeorm mysql @nestjs/typeorm 이렇게 3가지 모듈을 설치한다. npm install --save @nestjs/typeorm typeorm mysql 참고문서 documentation ","date":"2023-01-09","objectID":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/:6:1","tags":["NestJS"],"title":"nestJS 시작하기","uri":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"설정 src 폴더 아래 configs 폴더 생성 후 그 안에 typeorm.config.ts 파일 생성 DAO단 분리 기존 내가 알던 model폴더에서 000.dao.ts 라고 파일명을 붙였던 것과 달리, 소스 강의에서는 000.repository.ts 파일명을 사용하고 있다. 그 외에는 동일하다. ","date":"2023-01-09","objectID":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/:6:2","tags":["NestJS"],"title":"nestJS 시작하기","uri":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"게시물 삭제 remove()? vs delete()? remove 무조건 존재하는 아이템을 remove 메소드를 이용해서 지워야 한다. 그렇지 않으면 에러 발생(404 error) delete 만약 아이템이 존재하면 지우고 존재하지 않으면 아무런 영향이 없다. 이러한 차이로 remove를 이용하면 하나의 아이템을 지울 때 두번 데이터베이스를 이용해야 하기 때문에 (아이템 유무 + 지우기) 소스강의에서는 데이터베이스에 한번만 접근해도 되는 delete 메소드를 사용한다. ","date":"2023-01-09","objectID":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/:6:3","tags":["NestJS"],"title":"nestJS 시작하기","uri":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"Error Handling 에러를 잡아내고 싶다면 우선, try { await this.save(user) // \u003c- 이건 사용하고자 하는 코드 } catch(error) { console.log('error', error); } 를 이용하여 에러를 확인할 수 있다. http에서 해당 API를 돌려보면, 아래와 같은 로그를 터미널에서 확인할 수 있다. code: 'ER_DUP_ENTRY', errno: 1062, sqlMessage: \"Duplicate entry 'test' for key 'user.IDX_78a916df40e02a9deb1c4b75ed'\", sqlState: '23000', index: 0, sql: \"INSERT INTO `user`(`id`, `username`, `password`) VALUES (DEFAULT, 'test', 'te171')\" } 해당 error code 확인 후, 다시 아래와 같은 방식으로 수정하면 정상적으로 잡고자 하는 에러를 잡아낼 수 있다. try { await this.save(user); } catch (error) { if (error.code === 'ER_DUP_ENTRY') { throw new ConflictException('Existing username'); } else { throw new InternalServerErrorException(); } } 코드 수정 후, http Request 실행시 HTTP/1.1 409 Conflict X-Powered-By: Express Content-Type: application/json; charset=utf-8 Content-Length: 67 ETag: W/\"43-bvU5hJ7vN5ptmGJpSCIhkVNclIU\" Date: Mon, 16 Jan 2023 06:19:56 GMT Connection: keep-alive Keep-Alive: timeout=5 { \"statusCode\": 409, \"message\": \"Existing username\", \"error\": \"Conflict\" } statusCode 409부터 정상적으로 송출하고자 하는 에러 메세지까지 모두 이상없음을 확인가능하다. ","date":"2023-01-09","objectID":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/:7:0","tags":["NestJS"],"title":"nestJS 시작하기","uri":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"인증 및 인가 - bycriptjs ","date":"2023-01-09","objectID":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/:8:0","tags":["NestJS"],"title":"nestJS 시작하기","uri":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"hashedPassword 생성 및 검증 우선 인증 인가 부분에 필요한 bcrypt를 설치한다. npm install bcryptjs --save import는 다음과 같다. import * as bcrypt from 'bcryptjs'; 회원가입시, bcrypt로 hashedPassword 생성 //user.repository.ts @CustomRepository(User) export class UserRepository extends Repository\u003cUser\u003e { async createUser(authCredentialsDto: AuthCredentialsDto): Promise\u003cvoid\u003e { const { username, password } = authCredentialsDto; const salt = await bcrypt.genSalt(); // bcrypt가 들어간 코드 const hashedPassword = await bcrypt.hash(password, salt); // bcrypt가 들어간 코드 const user = this.create({ username, password: hashedPassword }); // bcrypt가 들어간 코드 try { await this.save(user); } catch (error) { if (error.code === 'ER_DUP_ENTRY') { throw new ConflictException('Existing username'); } else { throw new InternalServerErrorException(); } } } } 로그인시, hashedPassword를 비교하여 검증 ( bcrypt.compare) // user.service.ts async signIn(authCredentialsDto: AuthCredentialsDto): Promise\u003cstring\u003e { const { username, password } = authCredentialsDto; const user = await this.userRepository.findOneBy({ username }); if (user \u0026\u0026 (await bcrypt.compare(password, user.password))) { return 'login success'; } else { throw new UnauthorizedException('login failed'); } } ","date":"2023-01-09","objectID":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/:8:1","tags":["NestJS"],"title":"nestJS 시작하기","uri":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"jwt token 생성 필요 모듈 @nestjs/jwt : nestjs에서 jwt를 사용하기 위해 필요한 모듈 @nestjs/passport : JWT를 이용하여 인증 처리하는 등의 과정을 훨씬 쉽게 만들어주는 모듈 npm install @nestjs/jwt @nestjs/passport passport passport-jwt --save 위 터미널 명령어와 같이 총 4개의 모듈을 설치한다. @nestjs/jwt @nestjs/passport passport passport-jwt passport 사용 Passport 모듈이란? 토큰이 유효한 토큰인지 서버에서 secret text를 이용해서 알아내면 payload 안에 유저 이름을 이용해서, 데이터베이스 안에 있는 유저 이름에 해당하는 유저 정보를 모두 가져올 수 있다. 이러한 처리를 쉽게 해주는게 Passport 모듈이다. –\u003e 쉽게 말해 로그인 이후, 토큰 확인 과정을 말한다!!! npm install @types/passport-jwt --save Note nestJS의 미들웨어 Pipes : 파이프는 요청 유효성 검사 및 페이로드 변환을 위해 만들어진다. 데이터를 예상한 대로 직렬화 한다. Filters : 필터는 오류 처리 미들웨어이다. 특정 오류 처리기를 사용할 경로와 각 경로 주변의 복잡성을 관리하는 방법을 알 수 있다. Guards : 가드는 인증 미들웨어. 지정된 경로로 통과할 수 있는 사람과 허용되지 않는 사람을 서버에 알려준다. Interceptors : 인터셉터는 응답 매핑 및 캐시 관리와 함께 요청 로깅과 같은 전후 미들웨어. 각 요청 전후에 이를 실행하는 기능은 매우 강력하고 유용하다. Tip 각각의 미들웨어가 불러지는(called) 순서 middleware -\u003e guard -\u003e interceptor (before) -\u003e pipe -\u003e controller -\u003e service -\u003e controller -\u003e interceptor (after) -\u003e filter (if applicable) -\u003e client UseGuards UseGuards 안에 @nestjs/passport에서 가져온 AuthGuard()를 이용하면 요청안에 유저 정보를 넣어준 수 있다. @Post('/authTest') @UseGuards(AuthGuard()) authTest(@Req() req) { console.log(req) } UseGuards가 아닌 바로 객체에 접근하려면? 커스텀 데코레이터를 생성하여 접근할 수 있다. import { createParamDecorator, ExcutionContext } from '@nestjs/common' import { User } from './user.entity' export const GetUser = createParamDecorator((data, ctx: ExcutionContext): User =\u003e { const req = ctx.switchToHttp().getRequest() return req.user }) 위 예시는, UseGuards를 사용하고 그 안에 있는 정보를 사용하는 방법이기에 UseGuards가 필요하다. ","date":"2023-01-09","objectID":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/:8:2","tags":["NestJS"],"title":"nestJS 시작하기","uri":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"인증된 유저만 게시물을 사용할 수 있게 하기 우선 auth 모듈의 인증인가 부분을 boards 모듈에서도 사용할 수 있게 한다. // boards.module.ts @Module({ imports: [ TypeOrmExModule.forCustomRepository([BoardRepository]), AuthModule // \u003c- 추가 ], controllers: [BoardsController], providers: [BoardsService], }) //boards.controller.ts @Controller('boards') @UseGuards(AuthGuard()) // \u003c- 추가 컨트롤러 boards 아래 넣게되면 미들웨어처럼 작동하여, 모든 boards API는 토큰을 필요로 하게 된다. ","date":"2023-01-09","objectID":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/:8:3","tags":["NestJS"],"title":"nestJS 시작하기","uri":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"유저와 게시물 데이터의 관계 형성 사용자 1명은 여러개의 게시물을 작성할 수 있다. 때문에 OneToMany Relationship, ManyToOne Relationship의 성격을 동시에 가지는데, User Entity, Board Entity에서 각각 설정할 수 있다. //user.entity.ts @OneToMany(type =\u003e Board, board =\u003e board.user, { eager: true }) boards: Board[] //board.entity.ts @ManyToOne((type) =\u003e User, (user) =\u003e user.boards, { eager: false }) user: User; Tip option: eager true 일때는 user정보를 가져올 때, board도 같이 가져옴 ","date":"2023-01-09","objectID":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/:8:4","tags":["NestJS"],"title":"nestJS 시작하기","uri":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"Log 로그의 종류 Log - 중요한 정보의 범용 로깅 Warning - 치명적이거나 파괴적이지 않은 처리되지 않은 문제 Error - 치명적이거나 파괴적인 처리되지 않은 문제 Debug - 개발자용 / 오류 발생시 로직을 디버그하는 데 도움이되는 유용한 정보입니다. Verbose - 응용자용 / 응용 프로그램의 동작에 대한 통찰력을 제공하는 정보입니다. 예시 // main.ts import { NestFactory } from '@nestjs/core'; // \u003c- this import { AppModule } from './app.module'; import { Logger } from '@nestjs/common'; async function bootstrap() { const app = await NestFactory.create(AppModule); const port = 3000; await app.listen(port); Logger.log(`Application running on port ${port}`); // \u003c- this } bootstrap(); // board.controller.ts @Get() getAllBoard(@GetUser() user: User): Promise\u003cBoard[]\u003e { this.logger.verbose(`User ${user.username} trying to get all boards`); return this.boardsService.getAllBoards(user); } ","date":"2023-01-09","objectID":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/:9:0","tags":["NestJS"],"title":"nestJS 시작하기","uri":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"categories":["Node.js"],"content":"설정 .env 파일 사용 관련 필요 모듈 설치 npm install config --save // 또는 npm install dotenv --save ","date":"2023-01-09","objectID":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/:10:0","tags":["NestJS"],"title":"nestJS 시작하기","uri":"/posts/230109-nestjs-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"categories":["Miscellaneous"],"content":"tag : #coding #development source : 부트캠프 가셔도 실패하는 분 특징. 12년차 개발자가 말하는 프로그래머 롱런하는 방법 - YouTube youtube 서핑을 하다 우연히 보게 된 영상. “부트캠프 가셔도 실패하는 분 특징” 문구가 굉장히 도발적이었다. 마침 부트캠프를 막 수료한지라 더욱 내 시선을 끌었었다. youtube 내용 요약 - 펼치기 ","date":"2023-01-02","objectID":"/posts/230102-%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84-%EA%B0%80%EB%8F%84-%EC%8B%A4%ED%8C%A8%ED%95%98%EB%8A%94-%EC%82%AC%EB%9E%8C-%ED%8A%B9%EC%A7%95/:0:0","tags":["Miscellaneous"],"title":"부트캠프 가도 실패하는 사람 특징","uri":"/posts/230102-%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84-%EA%B0%80%EB%8F%84-%EC%8B%A4%ED%8C%A8%ED%95%98%EB%8A%94-%EC%82%AC%EB%9E%8C-%ED%8A%B9%EC%A7%95/"},{"categories":["Miscellaneous"],"content":"youtube 내용 요약 글쓰기를 잘하는 사람이 개발자로서도 잘한다. 본인의 메세지를 글에 녹일 수 있어야 한다. 컴퓨터가 이해할 수 있는 코드는 어느 바보라도 작성할 수 있다. 좋은 프로그래머는 사람이 이해할 수 있는 코드를 작성한다. 마틴 파울러, 리팩토링의 저자 코딩 자체가 문서를 정리하는 것이다. 때문에 중요한건 사고력과 논리력이다. 글을 잘 쓰면 기본적으로 이 2가지가 탑재되어 있다. 따라서 글쓰기를 잘한다면, 코드를 잘 작성할 수 있게 될 뿐만 아니라, 다른 사람과의 원활한 커뮤니케이션, 개발자 커리어에서 좋은 선택을 하는 것까지 가능하게 된다. ","date":"2023-01-02","objectID":"/posts/230102-%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84-%EA%B0%80%EB%8F%84-%EC%8B%A4%ED%8C%A8%ED%95%98%EB%8A%94-%EC%82%AC%EB%9E%8C-%ED%8A%B9%EC%A7%95/:1:0","tags":["Miscellaneous"],"title":"부트캠프 가도 실패하는 사람 특징","uri":"/posts/230102-%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84-%EA%B0%80%EB%8F%84-%EC%8B%A4%ED%8C%A8%ED%95%98%EB%8A%94-%EC%82%AC%EB%9E%8C-%ED%8A%B9%EC%A7%95/"},{"categories":["Miscellaneous"],"content":"이것부터 시작하면 반드시 개발자로 롱런 가능하다. 만약 당신이 이미 코드에서 프로그래밍적 기술에 대한 이해도가 높은 편이다? 코드에서 목적성을 갖고 짜는 연습을 하는 것이 베스트 기술적인 이해도가 낮다면? 프로그래밍적 기술보다 자연어!, 즉 일반적인 글로써 목적성이 있는 글 쓰기를 연습! 그렇다면, 목적성이 있는 글쓰기는 우선 무엇부터 쓸 수 있을까? 단순히 배운 것을 정리한다? =\u003e X 내가 다음에 00을 까먹었을때 나에게 다시 00을 가르칠 수 있도록 글을 써보겠다. =\u003e O 2번과 같은 구체적인 목적성이 있는 글이 좋다. 때문에 혼자 메모장에 쓰기보다는, 이 글을 나 이외에도 다른 누군가가 볼 수 있도록 블로그에 쓰는 것을 추천한다. 사실 이 영상과는 별개로 늘 WIL 블로깅을 하면서, 이 글이 과연 무슨 이점이 있을까? 나중에 내가 이 글을 볼때 나조차도 알아볼 수 없는 단순 메모에 불과하다면 이 글의 목적은 과연 무엇이었을까? 목적이 없는 글을 쓰는건 시간낭비가 아닐까? 라는 생각을 종종 하곤 했다. 부트캠프에서는 꾸준히 TIL(Today I leaned)을 쓰라고 했다. 1 일단 배운걸 그저 메모하듯이라도 쓰라고 했다. 아마 코딩을 처음 배우는 입장에서 목적성을 가진 글까지 쓰라고 하는건 무리였을까? 내가 배운 것을 정리한다. 그리고 시간이 지난 후, 이 글을 또 다른 누군가 보더라도 유의미한 글이 되게끔 글을 쓴다. 생각보다 1번은 쉽지만, 2번은 그렇지 않다. 대개 늘 2번에서 멈춘다. 마지막 탈고까지 들어가는 시간과 노력이 굉장히 많이 들기 때문이다. 나 역시도 현재, 초안으로 작성해놓고 탈고하지 못한 글만 해도 20여개가 넘는다. 하지만, 비록 시간과 품이 많이 들더라도 무의미한 글을 쓰는 것보다 훨씬 생산적이고, 글을 쓰는 동안 글의 목적, 효율적인 전달을 위한 개요, 구조, 문법, 어휘 등등을 끊임없이 생각하며 작성해나가는 것, 바로 그 자체가 또 다른 코딩 훈련이 아닐까? 사실 생각해보면 글쓰기와 코딩은 굉장히 비슷한 점이 많다. 하나의 API를 설계하기 위해 전체적인 그림을 그리고(주제 선정), 세부적인 기능을 배치하고(개요짜기), 기능을 개발하며 코드를 짜나간다(살 붙이기). 그리고 오류나 버그를 수정한다. (최종 탈고). 코딩 글쓰기 API 선정 주제 선정 기능 배치 및 설계 개요 짜기 기능 개발 살 불이기 디버깅 및 오류 수정 최종 탈고 유튜브 저자는 바로 이러한 점에서, 논리력과 사고력을 강조하며 글쓰기와 코딩을 함께 말하지 않았나 생각한다. 나는 이걸 WIL(What I leaned)로 조금 수정하여 사용중이다. 기존 TIL에서 WIL 방식으로 기록체계 변경 ~ cOdject ↩︎ ","date":"2023-01-02","objectID":"/posts/230102-%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84-%EA%B0%80%EB%8F%84-%EC%8B%A4%ED%8C%A8%ED%95%98%EB%8A%94-%EC%82%AC%EB%9E%8C-%ED%8A%B9%EC%A7%95/:1:1","tags":["Miscellaneous"],"title":"부트캠프 가도 실패하는 사람 특징","uri":"/posts/230102-%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84-%EA%B0%80%EB%8F%84-%EC%8B%A4%ED%8C%A8%ED%95%98%EB%8A%94-%EC%82%AC%EB%9E%8C-%ED%8A%B9%EC%A7%95/"},{"categories":["Back-End"],"content":"tag : #aws related link [AWS] 📚 EIP(탄력적 IP) 개념 \u0026 사용 세팅 정리 AWS EC2에서 백엔드 서버와 프론트엔드 서버를 돌리는 와중, 백엔드 서버의 PM2 리스트 전체가 다운이 되면서 멈추는 일이 발생했다. 이래저래 복구를 하다가, 프리티어 t2의 메모리 부족 현상때문이라는 결론에 다달았고 ec2를 재부팅하였다. ","date":"2022-12-28","objectID":"/posts/221228-aws-%ED%8D%BC%EB%B8%94%EB%A6%AD-ip%EC%99%80-%ED%83%84%EB%A0%A5%EC%A0%81-ip/:0:0","tags":["aws"],"title":"AWS 퍼블릭 IP와 탄력적 IP","uri":"/posts/221228-aws-%ED%8D%BC%EB%B8%94%EB%A6%AD-ip%EC%99%80-%ED%83%84%EB%A0%A5%EC%A0%81-ip/"},{"categories":["Back-End"],"content":"AWS 퍼블릭 IP 주소가 바뀌었다? EC2 재부팅 결과, 서버의 퍼블릭 IPv4 주소가 바뀌는 일이 발생했다. 왜 그런가 찾아보니 AWS 기술문서에 다음과 같은 안내가 있었다. ","date":"2022-12-28","objectID":"/posts/221228-aws-%ED%8D%BC%EB%B8%94%EB%A6%AD-ip%EC%99%80-%ED%83%84%EB%A0%A5%EC%A0%81-ip/:1:0","tags":["aws"],"title":"AWS 퍼블릭 IP와 탄력적 IP","uri":"/posts/221228-aws-%ED%8D%BC%EB%B8%94%EB%A6%AD-ip%EC%99%80-%ED%83%84%EB%A0%A5%EC%A0%81-ip/"},{"categories":["Back-End"],"content":"퍼블릭 IP 주소1 다음과 같은 경우 인스턴스의 퍼블릭 IP 주소가 변경됩니다. 중지되었거나 최대 절전 모드로 전환된 인스턴스는 다시 시작될 때 새 퍼블릭 IP 주소를 받습니다. 인스턴스의 연결된 엘라스틱 IP 주소가 인스턴스에서 연결 해제되는 경우, 새 퍼블릭 IP 주소를 받습니다. 퍼블릭 IP 주소가 더 이상 인스턴스와 연결되지 않으면 해당 주소는 퍼블릭 IP 풀로 돌아갑니다. 중지된 인스턴스에 대해 동일한 퍼블릭 IP 주소를 복구할 수 없습니다. 문제는 바뀐 주소를 프론트엔드 코드에서 다시 설정 해줘야 한다는 부분이었다. 다행히 프론트엔드 코드에서 백엔드 서버 주소는 .env 또는 config 파일로 변수처리를 해줬기때문에 간단한 작업만으로 가능했지만, 절대주소처럼 돌아가야 할 서버 주소가 앞으로도 언제든 바뀔 수 있다는 점은 그 때마다 프론트의 코드를 만져줘야 한다는 부분에서 큰 불편요소로 다가왔다. ","date":"2022-12-28","objectID":"/posts/221228-aws-%ED%8D%BC%EB%B8%94%EB%A6%AD-ip%EC%99%80-%ED%83%84%EB%A0%A5%EC%A0%81-ip/:1:1","tags":["aws"],"title":"AWS 퍼블릭 IP와 탄력적 IP","uri":"/posts/221228-aws-%ED%8D%BC%EB%B8%94%EB%A6%AD-ip%EC%99%80-%ED%83%84%EB%A0%A5%EC%A0%81-ip/"},{"categories":["Back-End"],"content":"AWS 퍼블릭 IP주소를 고정값으로 쓰려면?! ","date":"2022-12-28","objectID":"/posts/221228-aws-%ED%8D%BC%EB%B8%94%EB%A6%AD-ip%EC%99%80-%ED%83%84%EB%A0%A5%EC%A0%81-ip/:2:0","tags":["aws"],"title":"AWS 퍼블릭 IP와 탄력적 IP","uri":"/posts/221228-aws-%ED%8D%BC%EB%B8%94%EB%A6%AD-ip%EC%99%80-%ED%83%84%EB%A0%A5%EC%A0%81-ip/"},{"categories":["Back-End"],"content":"탄력적 IP 주소1 탄력적 IP 주소를 사용하는 것이 가장 좋습니다. 탄력적 IP 주소는 인스턴스가 아닌 계정에 할당됩니다. 필요에 따라 탄력적 IP 주소를 인스턴스와 연결할 수 있습니다. 계정에 할당된 탄력적 IP 주소는 해제 시 복구할 수 있습니다. 자세한 내용은 탄력적 IP 주소 복구를 참조하십시오. 모든 인스턴스는 중지될 때 연결된 탄력적 IP 주소를 유지합니다. AWS는 중지된 인스턴스와 연결된 탄력적 IP 주소에 대한 요금을 계속 청구합니다. 참고: 자동 할당된 동적 퍼블릭 IP 주소를 탄력적 IP 주소로 변환할 수 없습니다. ","date":"2022-12-28","objectID":"/posts/221228-aws-%ED%8D%BC%EB%B8%94%EB%A6%AD-ip%EC%99%80-%ED%83%84%EB%A0%A5%EC%A0%81-ip/:2:1","tags":["aws"],"title":"AWS 퍼블릭 IP와 탄력적 IP","uri":"/posts/221228-aws-%ED%8D%BC%EB%B8%94%EB%A6%AD-ip%EC%99%80-%ED%83%84%EB%A0%A5%EC%A0%81-ip/"},{"categories":["Back-End"],"content":"탄력적 IP의 비용은 어떻게 될까? ","date":"2022-12-28","objectID":"/posts/221228-aws-%ED%8D%BC%EB%B8%94%EB%A6%AD-ip%EC%99%80-%ED%83%84%EB%A0%A5%EC%A0%81-ip/:3:0","tags":["aws"],"title":"AWS 퍼블릭 IP와 탄력적 IP","uri":"/posts/221228-aws-%ED%8D%BC%EB%B8%94%EB%A6%AD-ip%EC%99%80-%ED%83%84%EB%A0%A5%EC%A0%81-ip/"},{"categories":["Back-End"],"content":"탄력적 IP 주소 요금 부과 2 실행 중인 인스턴스에 연결된 엘라스틱 IP 주소(EIP) 한 개는 무료로 사용할 수 있습니다. 해당 인스턴스에 추가 EIP를 연결하면 인스턴스와 연결된 추가 EIP당 시간에 비례하여 요금이 부과됩니다. 추가 EIP는 Amazon VPC에서만 사용할 수 있습니다. 탄력적 IP 주소의 효율적인 사용을 보장하기 위해 IP 주소가 실행 중인 인스턴스와 연결되어 있지 않거나, 중지된 인스턴스 또는 분리된 네트워크 인터페이스와 연결되어 있는 경우 소액의 시간당 요금이 부과됩니다. Bring Your Own IP를 사용하여 AWS로 가져온 IP 주소 접두사에서 생성하는 탄력적 IP 주소에 대해서는 요금이 부과되지 않습니다. AWS를 사용중이라면 1개까지는 무료로 사용가능하지만, 주의할 점은 탄력적 IP 주소를 생성 후, **사용하지 않는다면!! 요금이 부과된다는 점이다. ** (AWS 문서를 찾아보면 ip주소 점유 방지를 위함이라고 한다.) 탄력적 IP 생성과 사용 적용 및 삭제는 아래 블로그에서 아주 잘 설명되어있다. AWS - EIP(탄력적 IP) 개념 \u0026 사용 세팅 정리 EC2 인스턴스와 연결된 퍼블릭 또는 탄력적 IP 주소 복구 ↩︎ ↩︎ EC2 온디맨드 인스턴스 요금 – Amazon Web Services ↩︎ ","date":"2022-12-28","objectID":"/posts/221228-aws-%ED%8D%BC%EB%B8%94%EB%A6%AD-ip%EC%99%80-%ED%83%84%EB%A0%A5%EC%A0%81-ip/:3:1","tags":["aws"],"title":"AWS 퍼블릭 IP와 탄력적 IP","uri":"/posts/221228-aws-%ED%8D%BC%EB%B8%94%EB%A6%AD-ip%EC%99%80-%ED%83%84%EB%A0%A5%EC%A0%81-ip/"},{"categories":["project"],"content":"tag : #JustCode #project #fastfive ","date":"2022-12-27","objectID":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/:0:0","tags":["project_fastfive"],"title":"패스트파이브 기업과제 회고록","uri":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/"},{"categories":["project"],"content":"FastFive 프리온보딩 기업과제 ","date":"2022-12-27","objectID":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/:1:0","tags":["project_fastfive"],"title":"패스트파이브 기업과제 회고록","uri":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/"},{"categories":["project"],"content":"과제 진행간 개요 ","date":"2022-12-27","objectID":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/:2:0","tags":["project_fastfive"],"title":"패스트파이브 기업과제 회고록","uri":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/"},{"categories":["project"],"content":"기간 프로젝트 수행 기간 : 2022.12.12. Mon ~ 2022. 12.22. Thu (11일간) 최초 정식 코드 배포일 : 2022.12.22. Thu 프로젝트 보수 기간 : 2022.12.23. Fri ~ 2022.12.27. Tue (5일간) ","date":"2022-12-27","objectID":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/:2:1","tags":["project_fastfive"],"title":"패스트파이브 기업과제 회고록","uri":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/"},{"categories":["project"],"content":"인원 프론트엔드 3명, 백엔드 2명 ","date":"2022-12-27","objectID":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/:2:2","tags":["project_fastfive"],"title":"패스트파이브 기업과제 회고록","uri":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/"},{"categories":["project"],"content":"백엔드 기술스택 JavaScript, TypeScript, TYPEORM, mySQL, Node, Express ","date":"2022-12-27","objectID":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/:2:3","tags":["project_fastfive"],"title":"패스트파이브 기업과제 회고록","uri":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/"},{"categories":["project"],"content":"개발환경 OS : macOS 개발 tool : WebStrom, DBeaver, Postman 형상관리 : GitHub 문서관리 및 티켓관리 : Notion 협업 툴 : Slack ","date":"2022-12-27","objectID":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/:2:4","tags":["project_fastfive"],"title":"패스트파이브 기업과제 회고록","uri":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/"},{"categories":["project"],"content":"백엔드 기능분담 ERD 분석 및 작성 : 송인찬, 김**님 DBmate 세팅 : 송인찬 User API : 송인찬 category API : 송인찬 feedList API : 송인찬 reply API : 송인찬 posting API : 김**님 임시저장 posting: 김**님 임시저장 수정 posting: 김**님 정식저장 posting: 김**님 delete posting API : 송인찬 ","date":"2022-12-27","objectID":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/:2:5","tags":["project_fastfive"],"title":"패스트파이브 기업과제 회고록","uri":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/"},{"categories":["project"],"content":"결과 github 주소 ERD 구성 백엔드 API Documentation 배포 사이트 ","date":"2022-12-27","objectID":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/:2:6","tags":["project_fastfive"],"title":"패스트파이브 기업과제 회고록","uri":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/"},{"categories":["project"],"content":"최초 문서 분석 이번 프로젝트는 typescript라는 새로 배운 언어를 도입하여 진행하기로 하면서, 처음엔 아니었으나 프로젝트 종료시점에서 어쩌다 보니 내가 맡은 파트가 꽤… 많아졌다. 패스트파이브에서 준 개발 의뢰문서를 처음 봤을 때, 상세등록과 덧글 부분이 가장 난이도가 높아보였다. 난이도가 높다고 느껴진 부분은 다음과 같다. 상세등록 임시저장 : 1분마다 자동저장 이미지 업로드 (작성시점에 이미지 등록시 미리보기가 가능해야 함) 파일 업로드 (파일명과 파일 링크를 반환해야 함) 덧글 대댓글 구조 비공개 댓글의 경우 로그인 사용자별 내용 공개처리 ","date":"2022-12-27","objectID":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/:3:0","tags":["project_fastfive"],"title":"패스트파이브 기업과제 회고록","uri":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/"},{"categories":["project"],"content":"User API 작업을 시작하다 사실 개발문서에는 직접적인 user API 관련 언급은 없었다. 하지만 로그인한 사용자별 등급이 존재했었고, 이에 따른 커뮤니티 이용별 권한이 따로이 나눠져 있었다. 또한 최종적으로 website 링크를 배포 했을때 이러한 권한을 보여주려면 user API가 무조건 있어야 한다고 판단했다. 따라서 회원가입과 백엔드측에서 서버 세팅시 필요하게끔 약식으로 작성을 하였고, 로그인은 프론트엔드가 API 통신 테스트를 하는데 크게 문제되지 않도록 실제와는 달리 의도적으로 에러핸들링을 최소한으로 하였다. 회원권한조회 API user API 중 유일하게 가장 유용하면서도 의미있으며 필수적인 API로써, 로그인한 회원의 정보를 실시간으로 클라이언트(프론트엔드)에서 확인할 수 있도록 설계를 했다. \"user_id\": 9, \"write_permission\": true, \"is_admin\": true, \"member_type\": \"입주예정자\", \"company_name\": \"세탁 상태\", \"group_id\": 8, \"nickname\": \"reservation1\", \"email\": \"reservation1@test.com\", \"position_name\": \"대표\", \"start_date\": \"2023년 03월 01일\", \"end_date\": \"2023년 12월 31일\", \"period\": \"총 306일 계약\", \"group_feed_exist\": true, \"feed_id\": 8 해당 API는 위와 같은 응답 json을 반환한다. 로그인시, 위 정보를 한번에 줄수도 있겠지만 다음과 같은 이유로 따로 API를 분리시켰다. localStorage에는 최소한의 정보만이 암호화 된채 담겨야 한다. 회원의 권한과 관련된 정보는 localStorage에 저장되지 않는 것이 보안상 유리하다. API를 분리하여 사용함으로써 실시간으로 변경되는 권한 내역까지 잡아낼 수 있다. 실제 mySQL의 테이블에는 group의 start_date와 end_date만이 담기지만, 이를 바탕으로 model단에서 member_type(멤버 등급)과, write_permission(글쓰기 가능 조건, is_admin 권한이 있더라도 퇴주기업은 글쓰기 불가하기 때문), 그리고 period(해당 업체의 계약기간)를 담아 보낼 수 있도록 하였다. 또한, 회사의 멤버가 “우리회사 소개하기\"라는 버튼을 누를 때, 클라이언트가 회사의 글이 있으면 해당 게시글로 이동하고, 없다면 글쓰기 API로 이동시킬 수 있도록 group_feed_exist, feed_id를 찾아 반환할 수 있도록 하였다. sql where 절의 변수에서는 중간 탈취를 막기 위해 query injection처리를 하였다. mySQL query 펼치기 SELECT u.id AS user_id, (CASE WHEN date (ug.end_date) \u003e= date (now()) AND u.is_admin = TRUE THEN TRUE ELSE FALSE END ) AS write_permission, u.is_admin, (CASE WHEN date (ug.start_date) \u003c= date (now()) AND date (ug.end_date) \u003e= date (now()) THEN '입주자' WHEN date (ug.end_date) \u003c date (now()) THEN '퇴주자' WHEN date (ug.start_date) \u003e date (now()) THEN '입주예정자' ELSE '일반가입자' END ) AS member_type, ug.company_name, u.group_id, u.nickname, u.email, u.position_name, DATE_FORMAT(ug.start_date, '%Y년 %m월 %d일') AS start_date, DATE_FORMAT(ug.end_date, '%Y년 %m월 %d일') AS end_date, concat(\"총 \", TIMESTAMPDIFF(DAY, ug.start_date, ug.end_date) + 1, \"일 계약\") AS period FROM users u INNER JOIN user_group ug ON ug.id = u.group_id WHERE u.id = ? `, [userId] ","date":"2022-12-27","objectID":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/:4:0","tags":["project_fastfive"],"title":"패스트파이브 기업과제 회고록","uri":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/"},{"categories":["project"],"content":"가장 많이 고민한 reply API 댓글 테이블은 다음과 같은 구조를 가졌다. ","date":"2022-12-27","objectID":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/:5:0","tags":["project_fastfive"],"title":"패스트파이브 기업과제 회고록","uri":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/"},{"categories":["project"],"content":"대댓글은 자기참조 구조 활용 여기서 난 대댓글의 구조에서 parent_reply_id를 같은 테이블의 id값으로 잡는, 즉 자기참조 구조를 사용하였다. 최초에는 parent_reply_id에다 같은 테이블의 id값을 foreign key로 잡았었는데, 이 fk를 해제한 이유는 아이러니하게도 검색효율성 때문이었다. 1 isNull 함수 검색보다 const 상수검색으로 검색효율성 증대 이에 null일때, 0으로 입력되도록 default 값을 세팅 대댓글 그룹핑시 불필요한 함수 사용 제거 가능 read replies by feed API - mySQL query 펼치기 SELECT t2.id AS reply_id, t2.feed_id, u2.id AS feed_user_id, t2.is_private, t2.is_deleted, t2.comment, t2.parent_reply_id, u3.id AS parent_user_id, t2.reply_group, t2.rnk, u.id AS reply_user_id, ug.company_name, u.nickname, u.email, u.position_name, u.is_admin, CASE WHEN instr(DATE_FORMAT(t2.created_at, '%Y년 %m월 %d일 %p %h:%i'), 'PM') \u003e 0 THEN REPLACE(DATE_FORMAT(t2.created_at, '%Y년 %m월 %d일 %p %h:%i'), 'PM', '오후') ELSE REPLACE(DATE_FORMAT(t2.created_at, '%Y년 %m월 %d일 %p %h:%i'), 'AM', '오전') END AS created_at FROM ( SELECT * FROM ( SELECT r.id, r.is_private, r.is_deleted, r.user_id, r.feed_id, r.comment, r.parent_reply_id, r.created_at, RANK() OVER (PARTITION BY parent_reply_id ORDER BY id ASC ) AS rnk, r.parent_reply_id AS reply_group FROM replies r WHERE feed_id = 1 AND parent_reply_id) AS t1 UNION ALL ( SELECT r2.id, r2.is_private, r2.is_deleted, r2.user_id, r2.feed_id, r2.comment, r2.parent_reply_id, r2.created_at, r2.parent_reply_id AS rnk, r2.id AS reply_group FROM replies r2 WHERE r2.feed_id = 1 AND r2.parent_reply_id = 0 ORDER BY r2.id ASC ) ) AS t2 INNER JOIN users u ON t2.user_id = u.id LEFT JOIN replies r3 ON r3.id = t2.parent_reply_id LEFT JOIN users u3 ON u3.id = r3.user_id LEFT JOIN user_group ug ON ug.id = u.group_id LEFT JOIN feeds f ON f.id = t2.feed_id LEFT JOIN users u2 ON f.user_id = u2.id ORDER BY reply_group, rnk sql의 결과를 보기좋게 재가공!! read replies by feed API - typescript code 펼치기 .then(value =\u003e { value.map((e: any) =\u003e { if (value[0].parent_reply_id !== 0) { let temporary = { reply_id: e.parent_reply_id, parent_reply_id: 0, is_fake: true, }; value.unshift(temporary); } return value; }); value = [...value].map(item =\u003e { return { ...item, is_private: item.is_private === 1, is_deleted: item.is_deleted === 1, comment: item.comment === '0' ? false : item.comment, reply: [], }; }); value .filter( (e: any) =\u003e e.is_private === true \u0026\u0026 (e.reply_user_id || e.parent_user_id || e.feed_user_id) !== userId ) .map((e: any) =\u003e { e.comment = false; return e; }); value .filter((e: any) =\u003e e.parent_reply_id !== 0) .forEach((e: any) =\u003e value .find((re: any) =\u003e re.reply_id === e.parent_reply_id) .reply.push(e) ); return value.filter((e: any) =\u003e e.parent_reply_id === 0); }); 이리하여 나온 멋진 res.json은 아래 이미지와 같다. 풀이 댓글과 대댓글의 depth를 나눈 테이블구조가 아닌 자기참조 구조는 무한대댓글 구조를 구성할 수 있는 장점이 있다. 페이지네이션에서 댓글과 대댓글을 포함한 개수를 실행할 수 있도록 db에서는 대댓글을 분리하지 않은채 limit에 따라 댓글을 가져온다 비공개 댓글이나 삭제된 댓글은 로그인 유저의 정보에 따라 여기서 바로 내용을 false로 전환시킨다. (애시당초 클라이언트 쪽으로 데이터가 나가지 않도록 원천 차단) 페이지네이션으로 인한 n페이지의 최초 댓글이 대댓글일 경우, 원댓글 속에 들어가는 json 구조를 유지하기 위해 가상의 원댓글을 만들어주었다. 끝으로 대댓글은 댓글 속 reply라는 배열 안으로 모두 집어넣고, 최초의 json depth 단계에서는 원댓글들만 남게 함으로써, 클라이언트에서 구분하기 쉽게 response를 재가공하였다. 뿐만 아니라 이러한 구조에서 대댓글이 소속되는 원댓글에 대한 정보를 클라이언트에서 보다쉽게 구분할 수 있도록 reply_group이라는 컬럼을 추가생성되게 함으로써 원댓글 속으로 다시 한번 묶어주는 조건값을 생성해주고, 이 안에서 대댓글의 순서 정렬을 위해 rnk라는 컬럼을 추가로 만들었다. 프론트엔드에서는 왠만한 상황에서도 컴포넌트를 유지하는데 최대한 불편함 없이, 조건의 오류 없이 json데이터를 가져올 수 있도록 고민하고 설계하였다. 이 로직을 고민하는데 완전히 구현하는데 대략 이틀이나 걸렸다. ","date":"2022-12-27","objectID":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/:5:1","tags":["project_fastfive"],"title":"패스트파이브 기업과제 회고록","uri":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/"},{"categories":["project"],"content":"그외 기타 고민의 의사결정 과정들 하위 카테고리 설정 처음 카테고리를 설정할땐 직무 위주로 찾고 있었는데 문득, 패스트파이브는 B2B 업종이라는 걸 간과했다는 사실을 발견했다. 즉, 카테고리는 직무의 나열이 아니, 업종의 나열이 되어야 한다고 판단했다. 즉각 한국표준산업분류를 찾아봤고, 이에 따라 직무가 아닌 회사의 업종으로 나눌 수 있게끔 다시 세팅을 하였다. 퇴주자 글 단순 삭제시 - 데이터 유실의 문제점 삭제는 아니고 가림 =\u003e 2번으로 선택한 이유 기록! 왜?!! 퇴주기업의 게시글이라는 멘트로 공개 - 입주자 우선의 고객경험상 게시글 리스트가 오염될 수 있고, 데이터를 보호함으로써 패스트파이브에서는 추후 전체 데이터 통계 유의미한 멤버혜택 정보를 되려 게시글 작성자에게 추천할 수도 있다고 생각했다. ","date":"2022-12-27","objectID":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/:6:0","tags":["project_fastfive"],"title":"패스트파이브 기업과제 회고록","uri":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/"},{"categories":["project"],"content":"개선과정 반복코드들의 middleware 처리 controller단에서 무한히 반복되는 try-catch문을 따로 뽑아내어 미들웨어 처리함으로써 코드를 더 간결히 하였다. 대부분의 API에서 권한 검증을 함에 따라, 유저 권한 API를 jsonwebtoken 다음 단계로 하여 역시 미들웨어 처리하였다. router.post( '', catchMiddleware(authMiddleware), catchMiddleware(checkPermission), catchMiddleware(replyController.createReply) ); 배포 사이트에서 보는 이가 실제로 로그인해서 살펴볼 수 있도록 로그인 페이지와 해당 페이지에 시연용 ID와 PW를 남겨놓자고 건의하였고, 프론트엔드분들의 수고로 다음과 같이 남겨졌다. ","date":"2022-12-27","objectID":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/:7:0","tags":["project_fastfive"],"title":"패스트파이브 기업과제 회고록","uri":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/"},{"categories":["project"],"content":"회고 저스트코드의 과정중, 내게 이번 프로젝트는 따로 진행한 미니프로젝트를 포함한다면 4번째 프로젝트였다. 이전의 세 프로젝트와 다른 점은 이전까지의 클론프로젝트가 아닌, 즉, 모체가 없는 단순 문서만으로 진행해야하는 부분이었다. 때문에 ERD에서 고민이 조금 더 들어갔고, 이전의 프로젝트와는 달리, 프로젝트 진행 중간에 ERD 수정이 빈번히 이루어졌다. 프로젝트 단위로 코딩을 했을때 가장 좋은 점은 전체 사이클을 오롯이 한바퀴 돌려볼 수 있다는 점이었다. 때문에 기본적인 기능구현만을 위한 작업은 생각보다 금방 끝났고, 미들웨어 처리라던가, service단에서의 활용성 등 이전 프로젝트에 비해 코드를 더욱 조직화, 세분화함으로써 보다 복잡한 코드들을 나름 정리할 수 있었다. 어쩌다 보니 백엔드에서 많은 파트를 담당하게 되었는데 이는 내게 더 많은 도움과 공부가 되었다. 이제 어느정도 클론사이트의 경우 혼자서도 2주정도면 할수 있을것 같은 근거없는(?) 자신감도 생겼다. 새로운 길을 걷는 자에게 이런 자신감이 없다면 시작부터 흔들리거나 불안할 수 있다는 점에서 이는 큰 장점이라 생각한다. 이번 프로젝트에서 내가 목표로하였던 백엔드 지향점은 다음과 같다. 기획의도를 파악하여 타 부서와의 불필요한 조율 및 미팅을 최소화하고, 클라이언트 즉, 프론트엔드와의 비가시적인 동기화를 최대한 고려할 수 있는 조화로운 백엔드 엔지니어 이러한 점에서 이번 프로젝트에서는 전보다 더 많은 고민과 발전을 이루었음에, 아직 채워지지 않은 나의 포트폴리오 시작점에서 또하나의 유의미한 “한 자리\"를 기록하게 되었다. 아쉬웠던 점은, 클론사이트가 아니다보니 처음부터 프론트엔드와의 합을 맞추기까지 꽤나 오랜 시간이 걸렸고, 이로인해 API 통신 테스트까지의 일정이 다소 지연되었었다. 이번 경험은 실무에서 많은 도움이 될 것이다. 끝으로, 저스트코드의 과정이 끝남으로써 정기적으로 주어지는 프로젝트가 없다는 부분에서 오는 무료함과 상실감을 느끼게 되었다. 목표가 없다면 그것은 죽은 영혼이다!라는 글을 본적이 있다. 프로젝트를 진행할때의 그 긴장감과 일정을 맞추기 위한 적절한 압박감이 존재함을 느끼게 하였고, 코딩을 하는 내내 나 스스로가 몹시 즐거워한다는 점을 느꼈다. 이제 또 다른 목표를 잡으러 가봐야겠다. 참고 [블라인드 따라하기] 8. 대댓글 구현하기 - 디비 성능 개선기 : 네이버 블로그](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true\u0026blogId=1ilsang\u0026logNo=221569040532) ↩︎ ","date":"2022-12-27","objectID":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/:8:0","tags":["project_fastfive"],"title":"패스트파이브 기업과제 회고록","uri":"/posts/221227-%ED%8C%A8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%B4%EB%B8%8C-%EA%B8%B0%EC%97%85%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EA%B3%A0%EB%A1%9D/"},{"categories":["Back-End"],"content":"tag : #restAPI #restAPI 덧글 삭제 API 관련 코드 리팩토링 중, status code를 맞추다가 알게 된 사실! statusCode 204는 response를 전송하지 않는다!! 다만 status code “204” 만 전달할 뿐. 이걸 몰라서 코드의 오류인줄 알고 한참을 헤맸다. status code를 200으로 바꿨더니 다시 원래대로 response가 전송되었다. status code 문서의 개요만 어설프게 보고서는, 삭제니까 no content인 204가 맞겠지 하고 내 멋대로 이해한 실수였다. 204에서 다시 200으로 처리한 이유는, 삭제된 이후의 덧글 리스트와 페이지네이션 위치를 json으로 전달해야할 필요성이 있어서였다. ","date":"2022-12-25","objectID":"/posts/221225-status-code-204/:0:0","tags":["RESTful_API"],"title":"status code 204","uri":"/posts/221225-status-code-204/"},{"categories":["Back-End"],"content":"204 No Content 1 HTTP 204 No Content 성공 상태 응답 코드는 요청이 성공했으나 클라이언트가 현재 페이지에서 벗어나지 않아도 된다는 것을 나타냅니다. 기본값에서 204 응답은 캐시에 저장할 수 있습니다. 캐시에서 가져온 응답인 경우 ETag 헤더를 포함합니다. 흔히 204를 반환하는 경우는 PUT 요청에 대한 응답으로, 사용자에게 보여지는 페이지를 바꾸지 않고 리소스를 업데이트할 때 쓰입니다. 리소스를 생성한 경우엔 201 Created를 대신 반환합니다. 새롭게 업데이트한 페이지를 보여줘야 할 경우 200을 사용해야 합니다. 204 No Content - HTTP | MDN ↩︎ ","date":"2022-12-25","objectID":"/posts/221225-status-code-204/:0:1","tags":["RESTful_API"],"title":"status code 204","uri":"/posts/221225-status-code-204/"},{"categories":["Node.js"],"content":"tag : #typescript #typeorm #error source : 오류 해결1 related link ","date":"2022-12-13","objectID":"/posts/221213-typescript-typeorm-%EC%97%B0%EA%B2%B0-%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0/:1:0","tags":["TypeScript","typeORM"],"title":"typescript - typeorm 연결 오류 해결","uri":"/posts/221213-typescript-typeorm-%EC%97%B0%EA%B2%B0-%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0/"},{"categories":["Node.js"],"content":"typescript에서의 typeorm 연결 오류 대략 14시부터 22시까지 무려 8시간을 끼니도 거른채 뚫어져라 모니터만 쳐다보며 찾았다. type 지정이 잘못되었나? 아니면 새롭게 설치해줘야하는 npm이 있는건가? 눈이 빠져라 찾았는데 결과는 Success server.ts에서 dotenv.config() 바로 이 코드의 순서 문제였다. 기존 import createApp from './app.ts' 보다 아래에 있었는데 위로 올렸더니 바로 서버가 열렸다. dotenv.config() import createApp from './app.ts' // 윗줄과 순서 바꿈 동기/비동기 세션을 진행한게 오늘인데 바로 이러한 문제를 찾지 못하고 엉뚱한 곳에서 하루종일 헤매고 있었다니… 참고사이트 오류 해결1 Layered Pattern: test 목적으로 만들던 서버에서 발생한 에러 - 에러 종류 : throw new MissingDriverError_1.MissingDriverError - 에러의 원인 : 정확히 알수는 없으나 대개 app.js 에서 database 까지 연결이 되지 않을 때 나타난다. 처음에는 driver 에러라고 생각했으나 아니었다. 스펠링을 틀려서 연결이 안되거나 router 를 빠뜨려서 연결이 안되는 경우도 드라이버 문제로 나타났다. 정확히 하자면 typeorm 문제로 등장했다. - 디버깅 : 콘솔로 일일이 찍으면서 에러의 위치를 찾아야 한다. ⇒해결함 : 원인은 dotenv.config() 가 const routes = require(”….”) 보다 아래에 있어서 생겼다. 위치를 바꿔주니 서버가 잘 열렸다. ","date":"2022-12-13","objectID":"/posts/221213-typescript-typeorm-%EC%97%B0%EA%B2%B0-%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0/:1:1","tags":["TypeScript","typeORM"],"title":"typescript - typeorm 연결 오류 해결","uri":"/posts/221213-typescript-typeorm-%EC%97%B0%EA%B2%B0-%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0/"},{"categories":["Back-End"],"content":"mySQL을 사용하여 Database를 쌓아 나갈때, DBmate 를 사용하면 초기 세팅값을 마치 git을 저장하듯 이력을 남겨 언제든 migration 할 수 있다. 지금부터의 설명은 macOS 기준으로 기술한다. (windows가 없음 ;; ) ","date":"2022-10-18","objectID":"/posts/221018-dbmate-%EC%82%AC%EC%9A%A9%EB%B2%95/:0:0","tags":["DBmate"],"title":"DBmate 사용법","uri":"/posts/221018-dbmate-%EC%82%AC%EC%9A%A9%EB%B2%95/"},{"categories":["Back-End"],"content":"DBmate 설치 Homebrew 를 사용하여 설치한다. 1 터미널 아무 위치에서나 무관하다. 2 $brew install dbmate 이렇게 입력 후, 엔터키를 누르면 자동으로 설치가 된다. 그리고, 하나의 파일이 필요하다. 바로 .env 파일. IDE 또는 터미널 vim으로 .env 파일을 생성한 후, 다음과 같이 입력한다. \" cat.env \" 이런식으로 해도 되고, 바로 확장자부터 시작하는 파일명도 된다. 작성해야할 코드는 단 한줄! 아래와 같다. DATABASE URL=\"mysql://username: password@127.0.0.1:3306/database이름\" 주의사항 username : mySQL 서버 실행시 설정했던 이름을 넣으면 되는데 보통 root이다. database 위치 반드시 확인!! (localhost라면 127.0.0.1:3306 이 default 값이다.)3 기존의 database가 있다면 database 이름을 똑같이 적어야 한다. (아니면 또다른 이름의 DB생성됨) 주소 잘못 입력하면 아래 이미지와 같은 error 메세지를 무한히 받아볼 수 있다. ;; ","date":"2022-10-18","objectID":"/posts/221018-dbmate-%EC%82%AC%EC%9A%A9%EB%B2%95/:0:1","tags":["DBmate"],"title":"DBmate 사용법","uri":"/posts/221018-dbmate-%EC%82%AC%EC%9A%A9%EB%B2%95/"},{"categories":["Back-End"],"content":"DBmate 세팅 dbmate new create_users2_table 위와 같이 이라고 터미널에서 입력하면 migrations 폴더가 자동 생성되면서 users2라는 테이블이 생성할 수 있는sql 파일이 생성된다. 그리고 IDE나 vim에서 해당 sql 파일에 테이블 생성 규칙을 작성해주면 된다. ","date":"2022-10-18","objectID":"/posts/221018-dbmate-%EC%82%AC%EC%9A%A9%EB%B2%95/:0:2","tags":["DBmate"],"title":"DBmate 사용법","uri":"/posts/221018-dbmate-%EC%82%AC%EC%9A%A9%EB%B2%95/"},{"categories":["Back-End"],"content":"DBmate sql 문서 작성 위와 같이 제대로 파일이 생성되면 파일 편집시 이런 양식이 들어가있음을 볼 수 있다. -- migrate:up -- migrate:down -- migrate:up =\u003e table 생성시 넣고자 하는 코드 -- migrate:down =\u003e 보통 테이블 제거시 실행할 명령문 -- migrate:up create table users ( id integer, name varchar(255), email varchar(255) not null ); -- migrate:down drop table users2; 위와 같은 형식으로 작성된다. 제대로 했다면, 이게 끝이다. ","date":"2022-10-18","objectID":"/posts/221018-dbmate-%EC%82%AC%EC%9A%A9%EB%B2%95/:0:3","tags":["DBmate"],"title":"DBmate 사용법","uri":"/posts/221018-dbmate-%EC%82%AC%EC%9A%A9%EB%B2%95/"},{"categories":["Back-End"],"content":"migration 실행 $dbmate up 문서를 모두 작성 한 후, 터미널에서 명령어를 실행하면 이런 아름답고 꿈에 그리던 메세지를 받아볼 수 있다. 그리고 mySQL 서버로 가서 show tables; 를 입력해보자. 무사히 테이블이 생성되어 있음을 확인할 수 있다. dbmate down 위 명령어도 실행해보며 DBmate가 어떻게 돌아가는지 알면 좋다. 추가 보완해야 할 사항 위 문서에서는 하나의 테이블을 가지고 예를 들었는데, 명령어는 단순히 dbmate up이 끝이다. 만약 여러 테이블을 생성한다면?? 어떤 테이블을 up 하는 건지 table에 대한 지정이 없다. 즉, 아마도 테이블의 생성 순서에 따라 순차적으로 실행되지 싶은데, 이부분은 mock table을 여러개 만들어 직접 실험을 해봐야겠다. 참고문서 amacneil/dbmate: A lightweight, framework-agnostic database migration tool. dbmate 설치 / 사용 하기 Database migrations with Dbmate - M1lt0n on software java MySQL URL, 호스트, 포트 및 사용자 이름을 어떻게 알 수 있습니까? - 리뷰나라 참고로 맥에서 개발 관련 어플리케이션이나 cask 소프트웨어는 brew를 통해 설치 및 관리하는 것이 편하다… 라고 해서 그렇게 하고 있다. ↩︎ $ 몰랐는데 이게 그런 뜻인듯. ↩︎ 참고로 저 주소를 localhost:3306이라고 했다가 DBmate가 제대로 먹히질 않아서 1시간이나 헤맸다. 정확하게 써야 함! ↩︎ ","date":"2022-10-18","objectID":"/posts/221018-dbmate-%EC%82%AC%EC%9A%A9%EB%B2%95/:0:4","tags":["DBmate"],"title":"DBmate 사용법","uri":"/posts/221018-dbmate-%EC%82%AC%EC%9A%A9%EB%B2%95/"},{"categories":["env"],"content":"터미널을 처음 실행하면 꼭 사용자 폴더에서 시작한다. cd ...로 찾아가는게 너무 귀찮다. 그렇다고 finder에서 폴더를 drag \u0026 drop해서 직접경로를 떨어뜨리는 방법도 있지만, 굳이 키보드에서 또 마우스나 트랙패드로 손을 움직이고 싶지 않다. 때문에 알게 된 것이 바로 alias를 활용한 터미널 단축키 방법! 우선 zsh라는 쉘 을 한번 가볍게 알아본다. 힘들면 Pass하고, 바로 적용할 수 있는 방법으로 가자! ","date":"2022-10-13","objectID":"/posts/221013-%ED%84%B0%EB%AF%B8%EB%84%90%EC%97%90%EC%84%9C-%EB%B0%94%EB%A1%9C%EA%B0%80%EA%B8%B0-%EB%8B%A8%EC%B6%95%ED%82%A4-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0/:0:0","tags":["terminal"],"title":"터미널에서 '바로가기' 단축키 등록하기","uri":"/posts/221013-%ED%84%B0%EB%AF%B8%EB%84%90%EC%97%90%EC%84%9C-%EB%B0%94%EB%A1%9C%EA%B0%80%EA%B8%B0-%EB%8B%A8%EC%B6%95%ED%82%A4-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0/"},{"categories":["env"],"content":"1. zshrc 편집 터미널에서 다음을 실행 vim ~/.zshrc 이미 파일이 존재할수도 있고, 없으면 파일이 생성되며 바로 편집모드로 들어가게 된다. 파일 위치는 ~/ ","date":"2022-10-13","objectID":"/posts/221013-%ED%84%B0%EB%AF%B8%EB%84%90%EC%97%90%EC%84%9C-%EB%B0%94%EB%A1%9C%EA%B0%80%EA%B8%B0-%EB%8B%A8%EC%B6%95%ED%82%A4-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0/:0:1","tags":["terminal"],"title":"터미널에서 '바로가기' 단축키 등록하기","uri":"/posts/221013-%ED%84%B0%EB%AF%B8%EB%84%90%EC%97%90%EC%84%9C-%EB%B0%94%EB%A1%9C%EA%B0%80%EA%B8%B0-%EB%8B%A8%EC%B6%95%ED%82%A4-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0/"},{"categories":["env"],"content":"2. 단축키 입력 vim 모드에서 작성하기에 가장 기본적인 vim 사용법 2개만 알면 된다.1 i 또는 a키를 눌러 편집모드 진입 편집 편집이 끝나면 esc키를 눌러 명령어 모드 진입후, :wq 누르고 엔터! 이것이 기본적인 방법이고, 편집시 단축키 등록은 아래와 같이 입력하면 된다. alias 단축키=\"실행명령어\" 예를 들면, alias gocode=\"cd Users/codject/Documents/Code\" 예와 같이 등록했을 때, 터미널에서 gocode만 치면 바로 저 위치로 이동한다. 입력이 끝나면 :wq로 무사히 빠져나와 주면 된다. ","date":"2022-10-13","objectID":"/posts/221013-%ED%84%B0%EB%AF%B8%EB%84%90%EC%97%90%EC%84%9C-%EB%B0%94%EB%A1%9C%EA%B0%80%EA%B8%B0-%EB%8B%A8%EC%B6%95%ED%82%A4-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0/:0:2","tags":["terminal"],"title":"터미널에서 '바로가기' 단축키 등록하기","uri":"/posts/221013-%ED%84%B0%EB%AF%B8%EB%84%90%EC%97%90%EC%84%9C-%EB%B0%94%EB%A1%9C%EA%B0%80%EA%B8%B0-%EB%8B%A8%EC%B6%95%ED%82%A4-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0/"},{"categories":["env"],"content":"3. 단축키 등록 입력만 한다고 끝이 아니다. 입력한 zshrc를 터미널에 등록해줘야 한다. source ~/.zshrc 터미널에서 위와 같이 입력후 엔터를 치면, 단축키가 등록되었다며 리스트로 바로 뜬다. 이후 잘 쓰면 끝. 만약 단축키가 바로 동작하지 않는다면, 터미널을 완전종료 후, 재실행해주면 된다. 전체적인 참고 사이트 자주쓰는 명령어 .zshrc에 단축명령어 등록하기 더 자세히 알고 싶다면 Vim 단축키 정리 :: Outsider’s Dev Story 참고 ↩︎ ","date":"2022-10-13","objectID":"/posts/221013-%ED%84%B0%EB%AF%B8%EB%84%90%EC%97%90%EC%84%9C-%EB%B0%94%EB%A1%9C%EA%B0%80%EA%B8%B0-%EB%8B%A8%EC%B6%95%ED%82%A4-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0/:0:3","tags":["terminal"],"title":"터미널에서 '바로가기' 단축키 등록하기","uri":"/posts/221013-%ED%84%B0%EB%AF%B8%EB%84%90%EC%97%90%EC%84%9C-%EB%B0%94%EB%A1%9C%EA%B0%80%EA%B8%B0-%EB%8B%A8%EC%B6%95%ED%82%A4-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0/"},{"categories":["Front-End"],"content":"tag : #JavaScript justgram - UI 만들기 ","date":"2022-10-04","objectID":"/posts/221004-%EC%9D%B8%EC%8A%A4%ED%83%80%EA%B7%B8%EB%9E%A8-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%ED%99%94%EB%A9%B4-%EA%B5%AC%EC%84%B1/:0:0","tags":["html","css","JavaScript"],"title":"인스타그램 로그인 화면 구성","uri":"/posts/221004-%EC%9D%B8%EC%8A%A4%ED%83%80%EA%B7%B8%EB%9E%A8-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%ED%99%94%EB%A9%B4-%EA%B5%AC%EC%84%B1/"},{"categories":["Front-End"],"content":"Mission 1 - 로그인 페이지 레이아웃 처음 HTML 파일을 작성할때, display : flex; 를 쓰지 않았다. 결과는 원하는대로 나왔지만 나의 첫 코드는 쓸데없이 수많은 \u003cdiv\u003e와 \u003cp\u003e태그로 범벅이 됐다. HTML 초기버전 \u003cdiv class=\"wrapLoginBox\"\u003e \u003cdiv class=\"loginBox\"\u003e \u003cp id=\"title\"\u003ejustgram\u003c/p\u003e \u003cdiv class=\"inputBox\"\u003e \u003cp\u003e \u003cinput id=\"userInput\" type=\"text\" placeholder=\"전화번호, 사용자 이름 또는 이메일\"/\u003e \u003c/p\u003e \u003cp\u003e \u003cinput id=\"pwInput\" type=\"password\" placeholder=\"비밀번호\" /\u003e \u003c/p\u003e \u003cp\u003e\u003cbutton class=\"loginBtn\" disabled\u003e로그인\u003c/button\u003e\u003c/p\u003e \u003c/div\u003e \u003cdiv class=\"foot\"\u003e \u003ca href=\"https://www.instagram.com/accounts/password/reset/\"\u003e비밀번호를 잊으셨나요?\u003c/a\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e 위 코드가 처음 아무 생각없이 짠 HTML이다. 같은 팀원의 다른 코드를 우연히 봤는데 굉장히 정갈하고 깔끔했다. 깊게 반성하고 다시 HTML을 만졌다. HTML 수정버전 \u003cdiv class=\"wrapLoginBox\"\u003e \u003ch1 id=\"mainTitle\"\u003ejustgram\u003c/h1\u003e \u003cinput id=\"userInput\" type=\"text\" placeholder=\"전화번호, 사용자 이름 또는 이메일\" /\u003e \u003cinput id=\"pwInput\" type=\"password\" placeholder=\"비밀번호\" /\u003e \u003cbutton id=\"loginBtn\" disabled\u003e로그인\u003c/button\u003e \u003cdiv class=\"foot\"\u003e \u003ca href=\"https://www.instagram.com/accounts/password/reset/\"\u003e비밀번호를 잊으셨나요?\u003c/a\u003e \u003c/div\u003e \u003c/div\u003e 이것이 다시 짠 HTML ","date":"2022-10-04","objectID":"/posts/221004-%EC%9D%B8%EC%8A%A4%ED%83%80%EA%B7%B8%EB%9E%A8-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%ED%99%94%EB%A9%B4-%EA%B5%AC%EC%84%B1/:1:0","tags":["html","css","JavaScript"],"title":"인스타그램 로그인 화면 구성","uri":"/posts/221004-%EC%9D%B8%EC%8A%A4%ED%83%80%EA%B7%B8%EB%9E%A8-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%ED%99%94%EB%A9%B4-%EA%B5%AC%EC%84%B1/"},{"categories":["Front-End"],"content":"Mission 2 - ID, PW 입력 시 로그인 버튼 활성화 기능 ","date":"2022-10-04","objectID":"/posts/221004-%EC%9D%B8%EC%8A%A4%ED%83%80%EA%B7%B8%EB%9E%A8-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%ED%99%94%EB%A9%B4-%EA%B5%AC%EC%84%B1/:2:0","tags":["html","css","JavaScript"],"title":"인스타그램 로그인 화면 구성","uri":"/posts/221004-%EC%9D%B8%EC%8A%A4%ED%83%80%EA%B7%B8%EB%9E%A8-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%ED%99%94%EB%A9%B4-%EA%B5%AC%EC%84%B1/"},{"categories":["Front-End"],"content":"조건 Input 요소(Element)에 이벤트를 등록하여 글자 변화를 감지하게 만들어주세요!! 요소에 addEventListener로 이벤트 등록 ID 입력칸과(AND) PW 입력칸에 글자가 하나라도 들어가면 로그인 버튼 활성화 const idInput = document.getElementById(\"userInput\"); const pwInput = document.getElementById(\"pwInput\"); const btn = document.getElementById(\"loginBtn\"); // 1차 버전 function clickEnable() { if (!(idInput.value \u0026\u0026 pwInput.value)) { btn.disabled = true; } else { btn.disabled = false; btn.style.cursor = \"pointer\"; } } idInput.addEventListener(\"keyup\", clickEnable); pwInput.addEventListener(\"keyup\", clickEnable); // // 2차 버전 (input창이 다시 공란이 됐을때 완벽하게 원상태로 복귀하는 조건문) const idInput = document.getElementById(\"userInput\"); const pwInput = document.getElementById(\"pwInput\"); const btn = document.getElementById(\"loginBtn\"); function clickEnable() { if ((idInput.value.length \u0026\u0026 pwInput.value.length) !== 0) { console.log(\"disabled.false\"); btn.disabled = false; btn.style.cursor = \"pointer\"; btn.style.backgroundColor = \"rgba(65,147,239)\"; } else { btn.disabled = true; btn.style.removeProperty(\"cursor\"); btn.style.backgroundColor = \"rgba(198, 222, 250, 1)\"; } } idInput.addEventListener(\"input\", clickEnable); // 이벤트를 keyup에서 input으로 변경 pwInput.addEventListener(\"input\", clickEnable); // 이벤트를 keyup에서 input으로 변경 // 클릭 가능 \u0026 불가능 복귀되는지 확인용 함수 function btnCheck() { alert(\"클릭 가능\"); } btn.addEventListener(\"click\", btnCheck); 2차버전에서의 차이점1 idInput.value.length, pwInput.value.length의 변수 추가 (특정 문자열 수에 대한 활성화조건 변경시 바로 쓸 수 있음) 버튼이 활성화되고 난 후, 다시 비활성화될때 완벽한 조건으로의 복귀 및 CSS 속성 연결 추가 object.addEventListener의 이벤트 조건으로 keyup에서 input으로 변경 (키보드 컨디션 불량시에 대한 오류 방지 및 특정키에 대한 모든 오류 차단)2 대충 6시간 정도 혼자 삽질한 것 같다. ↩︎ 현재 쓰고 있는 블루투스 키보드의 keyup 신호가 한번씩 끊겼던 경험을 바탕으로 함 + 특정 기능키에 대해서도 완벽히 대처가능 ↩︎ ","date":"2022-10-04","objectID":"/posts/221004-%EC%9D%B8%EC%8A%A4%ED%83%80%EA%B7%B8%EB%9E%A8-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%ED%99%94%EB%A9%B4-%EA%B5%AC%EC%84%B1/:2:1","tags":["html","css","JavaScript"],"title":"인스타그램 로그인 화면 구성","uri":"/posts/221004-%EC%9D%B8%EC%8A%A4%ED%83%80%EA%B7%B8%EB%9E%A8-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%ED%99%94%EB%A9%B4-%EA%B5%AC%EC%84%B1/"},{"categories":["Front-End"],"content":"CSS 선택자 - 조합, 그룹, 가상 Quote HTML, CSS 실력을 단숨에 수직상승 시킬 수 있는 팁! 바로 ‘클론 코딩’ 입니다. 단순 반복의 목록형 페이지 - 쇼핑몰이 클론코딩을 하기에 실용적이고, 어렵지 않으면서도 자주 쓰이는 기술이 많이 들어갑니다. 여러분들이 자주 접속하는 쇼핑몰 중에 심플하고 세련된 사이트를 선정하여, 똑.같.이! 한 페이지만 만들어보세요. 개발자도구를 보면 HTML, CSS 힌트를 얻으실 수 있습니다. ","date":"2022-09-23","objectID":"/posts/220923-css-%EC%84%A0%ED%83%9D%EC%9E%90-%EC%A1%B0%ED%95%A9-%EA%B7%B8%EB%A3%B9-%EA%B0%80%EC%83%81/:1:0","tags":["css"],"title":"CSS 선택자 - 조합, 그룹, 가상","uri":"/posts/220923-css-%EC%84%A0%ED%83%9D%EC%9E%90-%EC%A1%B0%ED%95%A9-%EA%B7%B8%EB%A3%B9-%EA%B0%80%EC%83%81/"},{"categories":["Front-End"],"content":"CSS 선택자 ","date":"2022-09-23","objectID":"/posts/220923-css-%EC%84%A0%ED%83%9D%EC%9E%90-%EC%A1%B0%ED%95%A9-%EA%B7%B8%EB%A3%B9-%EA%B0%80%EC%83%81/:2:0","tags":["css"],"title":"CSS 선택자 - 조합, 그룹, 가상","uri":"/posts/220923-css-%EC%84%A0%ED%83%9D%EC%9E%90-%EC%A1%B0%ED%95%A9-%EA%B7%B8%EB%A3%B9-%EA%B0%80%EC%83%81/"},{"categories":["Front-End"],"content":"상속(Inheritance) 부모 자식관계의 태그나 요소에서 상위에서 설정된 스타일이 상속된다. 이를테면 body태그에 스타일을 지정하면, 해당 태그내의 모든 태그는 영향을 받아 스타일이 적용된다. ","date":"2022-09-23","objectID":"/posts/220923-css-%EC%84%A0%ED%83%9D%EC%9E%90-%EC%A1%B0%ED%95%A9-%EA%B7%B8%EB%A3%B9-%EA%B0%80%EC%83%81/:2:1","tags":["css"],"title":"CSS 선택자 - 조합, 그룹, 가상","uri":"/posts/220923-css-%EC%84%A0%ED%83%9D%EC%9E%90-%EC%A1%B0%ED%95%A9-%EA%B7%B8%EB%A3%B9-%EA%B0%80%EC%83%81/"},{"categories":["Front-End"],"content":"그룹(Grouping) 다중 요소의 스타일을 한번에 처리하고자 할때, 해당 요소 사이에 , 로 구분하여 처리한다. /* 예시 코드 */ .name, span, #hero, p color: green; 일관성이 필요한 스타일의 경우 유용하게 쓸 수 있으며, 한번에 유지보수가 가능한 이점이 있다. ","date":"2022-09-23","objectID":"/posts/220923-css-%EC%84%A0%ED%83%9D%EC%9E%90-%EC%A1%B0%ED%95%A9-%EA%B7%B8%EB%A3%B9-%EA%B0%80%EC%83%81/:2:2","tags":["css"],"title":"CSS 선택자 - 조합, 그룹, 가상","uri":"/posts/220923-css-%EC%84%A0%ED%83%9D%EC%9E%90-%EC%A1%B0%ED%95%A9-%EA%B7%B8%EB%A3%B9-%EA%B0%80%EC%83%81/"},{"categories":["Front-End"],"content":"조합 부모-자식간의 관계는 한칸 띄워쓰기로 표현한다. /* class=\"pre\" 안에 있는 모든 span태그를 지칭 */ .pre span { background-color: yellow; } 하나의 요소에서 클래스,ID로 조합될 경우에는 붙여쓰기로 표현한다. \u003cp\u003e빨간색으로 표현됨\u003c/p\u003e \u003cp id=\"hero\"\u003e빨간색에다가 밑줄 적용이 추가됨\u003c/p\u003e /* p태그의 컬러는 상속되고, hero아이디의 속성이 개별적으로 적용된다.*/ p { color: red; } p#hero { text-decoration: underline; } ","date":"2022-09-23","objectID":"/posts/220923-css-%EC%84%A0%ED%83%9D%EC%9E%90-%EC%A1%B0%ED%95%A9-%EA%B7%B8%EB%A3%B9-%EA%B0%80%EC%83%81/:2:3","tags":["css"],"title":"CSS 선택자 - 조합, 그룹, 가상","uri":"/posts/220923-css-%EC%84%A0%ED%83%9D%EC%9E%90-%EC%A1%B0%ED%95%A9-%EA%B7%B8%EB%A3%B9-%EA%B0%80%EC%83%81/"},{"categories":["Front-End"],"content":"CSS 적용 우선순위 inline styling (ex. \u003cp style=\"font-size: 30px;\"\u003e인라인스타일 적용\u003c/p\u003e) id class tag ","date":"2022-09-23","objectID":"/posts/220923-css-%EC%84%A0%ED%83%9D%EC%9E%90-%EC%A1%B0%ED%95%A9-%EA%B7%B8%EB%A3%B9-%EA%B0%80%EC%83%81/:2:4","tags":["css"],"title":"CSS 선택자 - 조합, 그룹, 가상","uri":"/posts/220923-css-%EC%84%A0%ED%83%9D%EC%9E%90-%EC%A1%B0%ED%95%A9-%EA%B7%B8%EB%A3%B9-%EA%B0%80%EC%83%81/"},{"categories":["Front-End"],"content":"CSS - Image Sprite Image Sprite란? 화면에 필요한 이미지 하나하나가 파일이고, 네트워크 요청을 하기 때문에 비용이 든다. 하나의 이미지 파일에 모든 이미지를 담은 후, 위치를 조정하며 골라 사용하는 방법 장점 10개의 아이콘이 10개의 파일로 존재한다면 10번을 요청하게 되지만, 1번의 요청으로 줄어들어 웹 성능의 향상을 기대할 수 있다. 이미지를 불러올 때마다 화면에 표현하기 위해 잠깐의 깜빡임이 생기는데, 하나의 이미지파일을 사용하면 이미 브라우저에서 불러온 파일이라 이 깜빡임이 없다. 단점 디자이너와 소통이 필요함 이미지가 하나만 수정되어도 파일이 변경되어야 함 각 이미지의 위치(좌표)를 정확히 관리해야 함 ","date":"2022-09-22","objectID":"/posts/220922-css-image-sprite/:0:1","tags":["css"],"title":"CSS - Image Sprite","uri":"/posts/220922-css-image-sprite/"},{"categories":["Front-End"],"content":"Image sprite 기법 다음은 NAVER 메인페이지의 메뉴아이콘이 할당되어있는 배경이미지 파일이다. \u003c위 이미지는 실제 Naver 메인화면에서 따온 파일이다.\u003e 저 파일에서 하나의 이미지를 불러오고자 한다면, 좌상단을 기준으로하여 불러오고자 하는만큼의 px값으로 처리한다. 이때, 좌표의 수치 규칙은 다음과 같다. 가로는 오른쪽 방향으로 + 수치 증가 세로는 아래 방향으로 + 수치 증가 예제코드 \u003cdiv class=\"empty-profile\"\u003e\u003c/div\u003e .empty-profile { width: 314px; height: 314px; background: url(\"https://s.pstatic.net/static/www/img/uit/sp_main_dba1af.png\") no-repeat; } 중간에 있는 이미지를 골라쓰려면? 앞서 좌상단 0, 0 좌표를 기준으로 한 뒤, 이미지의 폭과 너비의 값으로 불러온다고 했다. 그럼 중간에 있는 것들은 어떻게 불러올까? 기준값 0, 0을 background-position 값으로 조정하여 옮겨준다. 코드를 살펴보자 \u003cdiv class=\"input-tool\"\u003e\u003c/div\u003e .input-tool { width: 130px; height: 80px; background: url(\"https://s.pstatic.net/static/www/img/uit/sp_main_dba1af.png\") no-repeat; background-position: -315px -225px; } background-position: -315px -225px; 바로 이 부분이다. 여기서 주의할 점은, 가로, 세로 좌표에서의 - 기호이다. 기준점 변경에 대한 기준이 바로 기준점 그 자체이기 때문인데, 쉽게 생각하자면 배경이미지에서 기준점이 옮겨진다면 저 기호는 +가 되어야 하겠지만, 반대로 기준점을 그대로 두고 그 뒤에서 배경이미지가 역으로 움직인다고 생각해보자. 그럼 쉽게 이해할 수 있다. 근데 대체 왜 이런 좌표기준 방식을 썼을까? 혼자 상상해본다. 만약 1번의 상황으로 간다면 위 코드는 다음과 같이 바뀔것이다. .input-tool { width: 415px; height: 305px; background: url(\"https://s.pstatic.net/static/www/img/uit/sp_main_dba1af.png\") no-repeat; background-position: 315px 225px; } 이 방식은 코드만으로 이미지의 크기를 직관적으로 알기가 힘들다. 아마 이런 문제 때문에 2번의 방식을 쓴걸까? ","date":"2022-09-22","objectID":"/posts/220922-css-image-sprite/:1:0","tags":["css"],"title":"CSS - Image Sprite","uri":"/posts/220922-css-image-sprite/"},{"categories":["JavaScript"],"content":"JavaScript - Basic ","date":"2022-09-12","objectID":"/posts/2022-09-12-javascript-basic-%EB%B3%80%EC%88%98/:1:0","tags":["JavaScript"],"title":"JavaScript - basic 변수","uri":"/posts/2022-09-12-javascript-basic-%EB%B3%80%EC%88%98/"},{"categories":["JavaScript"],"content":"변수 변수는 2단계로 이루어진다. 변수의 선언 변수에 대한 값을 할당 let myNumber // myNumber라는 변수를 \"선언\" myNumber = 100 // 앞에서 선언한 변수에 값을 \"할당\" 용어 정리 - 변수 : 데이터를 담을 수 있는 대상 - 변수의 선언과 변수에 대한 값을 할당하는 것은 별개이다. 일반적으로 변수의 선언과 할당이 동시에 이루어진다. (아래 코드 참조) let myNumber = 100 ","date":"2022-09-12","objectID":"/posts/2022-09-12-javascript-basic-%EB%B3%80%EC%88%98/:1:1","tags":["JavaScript"],"title":"JavaScript - basic 변수","uri":"/posts/2022-09-12-javascript-basic-%EB%B3%80%EC%88%98/"},{"categories":["JavaScript"],"content":"변수를 선언하는 명령어 var, let, const 각각의 차이는?? 종류 선언 재선언 재할당 var O O O let O X O const O X X 위 표와 같이 즉, let이나 const는 이미 선언했던 변수를 다시 선언할 수 없다. 하지만 let의 경우 값은 재할당 할 수 있다. let name = 'abc' console.log(name) // abc let name = 'let' console.log(name) // SyntaxError: Identifier 'name' has already been declared // 그러나 값을 재할당하는 것은 가능하다 name = 'let' console.log(name) // let ‘변수의 2단계’를 완벽히(?) 이해하지 못한다면 위 코드에서 let의 차이를 제대로 알 수 없다. ","date":"2022-09-12","objectID":"/posts/2022-09-12-javascript-basic-%EB%B3%80%EC%88%98/:1:2","tags":["JavaScript"],"title":"JavaScript - basic 변수","uri":"/posts/2022-09-12-javascript-basic-%EB%B3%80%EC%88%98/"},{"categories":["JavaScript"],"content":"원시변수의 Data Type Boolean 논리적인 요소를 나타낸다. true, false의 2가지 값을 가진다. Null null(빈 값)을 가진다. Undefined 값을 할당하지 않았을때, undefined를 가지게 된다. Number 숫자 요소를 나타낸다. 정확히는 Integer(정수)를 뜻한다. String 문자열을 나타낸다. 할당시 quotation(따옴표)로 반드시 감싸줘야 한다. Tip Null과 Undefined의 차이 간단히 말하자면 의도성으로 나눌 수 있다. Null은 의도적으로 값을 할당하지 않은 상태를 뜻하며, Undefined는 아직 값을 할당하지 않은 상태이다. 즉, 변수를 선언만 하고 값을 할당하지 않았을때에는, 기본적으로 Undefined 값이 할당된다. undefined와 null의 차이점을 설명하세요 | 2ssue’s dev note 참조 ","date":"2022-09-12","objectID":"/posts/2022-09-12-javascript-basic-%EB%B3%80%EC%88%98/:1:3","tags":["JavaScript"],"title":"JavaScript - basic 변수","uri":"/posts/2022-09-12-javascript-basic-%EB%B3%80%EC%88%98/"},{"categories":["JavaScript"],"content":"잦은 실수 string 입력시 quatation marks(따옴표)를 깜빡해서 잦은 오류가 난다. 함수 내에서 result는 =을 사용하지 않는데 등호를 붙일 때가 있다. return과 console.log의 차이 return은 그 값을 변수에 할당 가능 console.log는 변수에 할당 불가능 매개변수와 인수의 차이 function order(매개변수) { ... input } console.log(order(인수)) 비슷하지만 다른 역할이다. 매개변수(parameter)는 함수에서 사용할 값을 외부에서 받아들리이기 위해 정의된 변수! 인수(argument)는 함수 호출시, 매개변수로 전달할 값!! ","date":"2022-09-12","objectID":"/posts/2022-09-12-javascript-basic-%EB%B3%80%EC%88%98/:1:4","tags":["JavaScript"],"title":"JavaScript - basic 변수","uri":"/posts/2022-09-12-javascript-basic-%EB%B3%80%EC%88%98/"},{"categories":["Front-End"],"content":"font Awesome 사용하기 다양한 아이콘을 사용하게 될 때가 있다. 이때 유용한 사이트가 바로 font Awesome이다. 주의할 점은, 간혹 아이콘이 작동하지 않을때가 있다. font Awesome의 HTML 태그는 아래 코드처럼 \u003ci\u003e로 시작한다. \u003ci class=\"fa-solid fa-heart\"\u003e\u003c/i\u003e 이때 버전을 호환하지 않으면 간혹 이탤릭체로 인식하고 아이콘이 나타나지 않는다. 이것은 font Awesome의 버전이 호환되지 않아 생기는 문제로서, 아래 코드를 HTML에 입력해두면 해결된다. \u003cscript src=\"https://use.fontawesome.com/releases/v5.2.0/js/all.js\"\u003e\u003c/script\u003e 저기서 v5.2.0부분을 해당 버전으로 고쳐 입력하면 된다. 1 즉 호환되는 버전을 살펴보며 아이콘을 골라야지 무턱대고 골랐다가는 HTML에서 꼬이는 경우가 생길 수 있다. Font Awesome 5 / HTML 문서에 연결하고 아이콘 넣기 – CODING FACTORY 참고 ↩︎ ","date":"2022-09-06","objectID":"/posts/2022-09-06-font-awesome-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/:0:1","tags":["fontAwesome"],"title":"font Awesome 사용하기","uri":"/posts/2022-09-06-font-awesome-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/"}]