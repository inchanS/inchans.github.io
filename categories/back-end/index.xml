<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Back-End - Category - inchan.dev</title>
        <link>https://inchan.dev/categories/back-end/</link>
        <description>Back-End - Category - inchan.dev</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>song@inchan.dev (inchan)</managingEditor>
            <webMaster>song@inchan.dev (inchan)</webMaster><lastBuildDate>Fri, 26 Jan 2024 11:49:52 &#43;0900</lastBuildDate><atom:link href="https://inchan.dev/categories/back-end/" rel="self" type="application/rss+xml" /><item>
    <title>Node.js에서 OOP 기반 리포지토리에 적용한 싱글톤 디자인패턴</title>
    <link>https://inchan.dev/posts/202401261149/</link>
    <pubDate>Fri, 26 Jan 2024 11:49:52 &#43;0900</pubDate>
    <author>inchan</author>
    <guid>https://inchan.dev/posts/202401261149/</guid>
    <description><![CDATA[Project Tech Stack Overview Language: TypeScript
Platform: Node.js
Web Framework: Express.js
Database: MySQL
ORM: TypeORM
Cloud Storage: AWS S3
Development Tool: WebStorm
Version Control and Issue Tracking: GitHub Issue
얼마 전, 모든 코드를 OOP로 리팩토링한 뒤, 한 문제를 발견했다.
리포지토리 역시 클래스 기반으로 내보내고 있었는데 때문에 각각의 서비스 로직에서는 이를 new Class() 형태로 불러오면서 단일 인스턴스가 아닌 여러 인스턴스의 생성 위험이 있었다.
OOP 리팩토링 전, 함수기반에서는 최초 호출된 datasource 인스턴스 하나를 계속해서 사용하기에 문제가 없었는데 이 부분을 간과했다.]]></description>
</item>
<item>
    <title>AWS EC2 서버에 HTTPS 적용하기</title>
    <link>https://inchan.dev/posts/202401122216/</link>
    <pubDate>Wed, 10 Jan 2024 22:17:59 &#43;0900</pubDate>
    <author>inchan</author>
    <guid>https://inchan.dev/posts/202401122216/</guid>
    <description><![CDATA[팀 프로젝트로 백엔드 서버를 EC2에서 배포하여 사용중인데 여기에 HTTPS를 적용하여 보았다.
겁먹지 말기 AWS내에서 각 서비스를 이리저리 다니며
무언가를 자꾸 생성하고 또 세팅하다보니 자칫 어렵다고 지레 겁먹기 쉬운데
실제로 해보면 생각보다 간단하고 쉽다. 구글링을 하다보면 여러 관련 글이 있는데 아래 참고한 2개의 웹페이지가 가장 잘 설명되어있다.
EC2 HTTPS로 연결하기 EC2에 HTTPS 적용하기 미리 말해두기 해당 참고 사이트의 글을 보다보면 친절하게 잘 설명되어있음에도 살짝씩 어리둥절할 때가 있다.
왜냐면 AWS 웹 UI가 생각보다 자주 바뀌는듯 해서 설명에 참고된 스크린샷과 현재 시점의 AWS 화면이 다르기 때문이다.]]></description>
</item>
<item>
    <title>AWS EC2에서 product 서버와 개발용 서버 같이 사용하기</title>
    <link>https://inchan.dev/posts/202306191659/</link>
    <pubDate>Mon, 19 Jun 2023 16:59:51 &#43;0900</pubDate>
    <author>inchan</author>
    <guid>https://inchan.dev/posts/202306191659/</guid>
    <description><![CDATA[프로젝트를 진행하다보면 필연적으로 프론트엔드와의 통신교류가 필요하고,
이 때마다 local server로 열기보단 상시 열려있는 server가 있는 것이 훨씬 편하다.
때문에 이러한 개발과정상 필요한 back-end의 통신교류용 API 서버를 AWS EC2에서 간편하게 열어 사용하는 방법에 대해 기술하려 한다.
초기 처음 통신교류를 위한 서버는 VScode의 Live Share Extension을 이용하였다.
방법은 다음과 같다.
extensions에서 Live Share 설치 좌측 사이드 메뉴에서 Live Share 아이콘 클릭 Share 버튼을 클릭하면 실시간 공유가 시작된다. 여기서 Shared Servers를 클릭하고 상단 검색창에 포트 번호를 입력후, enter를 누르면 해당 포트로 서버가 공유된다.]]></description>
</item>
<item>
    <title>AWS RDS 데이터 - 다른 계정으로 이전하기</title>
    <link>https://inchan.dev/posts/202306191507/</link>
    <pubDate>Mon, 19 Jun 2023 15:07:40 &#43;0900</pubDate>
    <author>inchan</author>
    <guid>https://inchan.dev/posts/202306191507/</guid>
    <description><![CDATA[서로 다른 AWS의 계정간 RDS의 데이터를 이전하는 방법에 대해 소개한다.
AWS RDS 계정간 이동 우선 간략히 설명하자면 순서는 다음과 같다.
Info 구 계정에서 스냅샷 생성 생성이 완전히 완료되면 스냅샷 공유 탭이 활성화된다. 스냅샷 공유에서 private 선택후, 계정란에 이전할 새로운 계정의 ID 입력 이전할 새 계정으로 로그인 후, RDS에서 좌측 사이드바의 스냅샷 메뉴 - 상단 나와 공유된 스냅샷 탭 클릭 마이그레이션 선택! (RDS 세팅시 프리티어라고 따로 설정하는 안내가 없으니 잘 보고 세팅) 끝!]]></description>
</item>
<item>
    <title>MySQL에서 이메일 재사용 가능하게 하기- Soft Delete와 Unique를 함께 활용하다.</title>
    <link>https://inchan.dev/posts/202306070208/</link>
    <pubDate>Wed, 07 Jun 2023 02:08:24 &#43;0900</pubDate>
    <author>inchan</author>
    <guid>https://inchan.dev/posts/202306070208/</guid>
    <description><![CDATA[개발환경 Javascript 런타임 플랫폼: Node.js 언어: TypeScript 프레임워크: Express DB: MySQL ORM: TypeORM 현재 조건 상황 회원가입시, 이메일과 패스워드가 필수 입력입력인데, 이메일의 경우 mySQL에서 unique 처리 회원가입 과정에서 이메일 중복 여부를 확인하고 통과했을 경우에만 회원가입 가능 회원 삭제시, 실제 회원정보를 DB에서 지우지 않고 TypeORM의softDelete 방식으로 deleted_at 컬럼에 삭제일시가 기록되는 방식 (일정기간 이후 삭제할 요량으로 단기간 데이터 보존) Question 이미 회원 삭제된 정보의 이메일로 재가입하려는 경우,
해당 이메일은 이미 mySQL에서 unique로 입력되어있는 이메일이기 때문에 이메일 중복확인에서 통과되지 않는다.]]></description>
</item>
<item>
    <title>Swagger를 이용한 백엔드의 효과적인 API명세 전달</title>
    <link>https://inchan.dev/posts/202303080503/</link>
    <pubDate>Wed, 08 Mar 2023 05:14:43 &#43;0900</pubDate>
    <author>inchan</author>
    <guid>https://inchan.dev/posts/202303080503/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://images.unsplash.com/photo-1516321497487-e288fb19713f?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=2670&amp;q=80" referrerpolicy="no-referrer">
            </div>사진출처: unsplash
백엔드가 효과적인 명세 전달 고민 Failure 그동안 진행했던 프로젝트에서 제대로 된 API 명세를 적시에 프론트측에 전달하지 못했고,
때문에 최종 출시를 앞두고 서로간의 코드 오류를 잡느라 시간적 비용이 꽤나 낭비됐다. 간단하게는 Request Body 값의 TYPE과 관련된 소통 혼선으로 겪었던 헤프닝도 더러 있었다. 어떻게 하면 좋을까? 우선은 백엔드의 입장에서 생각해본다.
명세는 코드가 만들어지면서 늘 수정될 수 있다. 때문에 명세는 코드와 함께 작업되어야 하고, API 테스트를 위해 즉각적으로 수정되어야 한다. 같은 백엔드 팀의 경우에는 직접 코드를 보기에 명세의 부족함을 보완할 수는 있다.]]></description>
</item>
<item>
    <title>typeORM transaction에서 repository 사용하기</title>
    <link>https://inchan.dev/posts/202302250414/</link>
    <pubDate>Sat, 25 Feb 2023 04:14:31 &#43;0900</pubDate>
    <author>inchan</author>
    <guid>https://inchan.dev/posts/202302250414/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://images.unsplash.com/photo-1555421689-491a97ff2040?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxzZWFyY2h8MTV8fHRyYW5zYWN0aW9ufGVufDB8fDB8fA%3D%3D&amp;auto=format&amp;fit=crop&amp;w=900&amp;q=60&amp;h=300" referrerpolicy="no-referrer">
            </div>&lt;사진: unsplash&gt;
transaction 구성중 Entity가 아닌 Repository 사용시 typeORM에서 transaction을 사용하는 방법은 몇가지가 있지만,
복잡한 service단의 처리에서는 아래의 queryRunner 방식이 더 적합할것 같아서
dataSource.createQueryRunner() 방식을 사용했다.1
// transaction으로 묶어주기 const queryRunner = dataSource.createQueryRunner(); await queryRunner.connect(); await queryRunner.startTransaction(); try { // feed 저장 let newTempFeed: Feed = plainToInstance(FeedDto, feedInfo); const tempFeed = await FeedRepository.createFeed(newTempFeed); //&lt;- 문제!! // ... 추가 코드들 } catch (err) { await queryRunner.rollbackTransaction(); throw new Error(`createTempFeed TRANSACTION error: ${err}`); } finally { await queryRunner.]]></description>
</item>
<item>
    <title>Node.js 백엔드TypeScript &#43; typeORM으로 무한 대댓글 가공하기</title>
    <link>https://inchan.dev/posts/202302160417/</link>
    <pubDate>Thu, 16 Feb 2023 04:17:07 &#43;0900</pubDate>
    <author>inchan</author>
    <guid>https://inchan.dev/posts/202302160417/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://images.unsplash.com/photo-1672308627194-9a2c28daa17a?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxzZWFyY2h8NXx8dHlwZXNjcmlwdHxlbnwwfHwwfHw%3D&amp;auto=format&amp;fit=crop&amp;w=900&amp;q=60&amp;h=300" referrerpolicy="no-referrer">
            </div>&lt;사진: unsplash&gt;
기능 구현 목표 댓글, 대댓글&hellip; 대댓글 등의 무한대댓글 구조 typeORM의 Entity를 연계한 createQueryBuilder 등을 지향하며, 최대한 직접적인 QueryRunner 방식 지양 삭제 및 비공개 댓글 가림 json 출력시 불필요한 요소 제거 (특히 Date 타입에서 !! ) 가장 오랜시간을 지연시켰던 Blocker typeORM createQueryBuilder 메소드로 출력시 2023-02-14T08:55:24.090Z // ^ ^^^^ &lt;- 거추장스럽다. 이런 식으로 나오는 문제가 있는데 꽤나 씨름했다. 우선 Entity의 Date type은 datetime이 아닌 timestamp로 했다.
mySQL에서의 출력은 DB가 설치된 서버의 시간대를 따르기에]]></description>
</item>
<item>
    <title>백엔드 - typescript-express 환경에서 jest 및 node 환경에 따라 dotenv 설정 분리</title>
    <link>https://inchan.dev/posts/202301230424/</link>
    <pubDate>Mon, 23 Jan 2023 04:24:50 &#43;0900</pubDate>
    <author>inchan</author>
    <guid>https://inchan.dev/posts/202301230424/</guid>
    <description><![CDATA[문제상황 TDD 방법론을 따라 프로젝트를 진행하려는데 Jest를 이용하여 test 코드를 작성하던 중,
한가지 문제를 마주한다.
test를 위한 DB는 그 조건에 따라 생성되고 삭제되어지는 특성상,
실제 개발환경에서의 DB와 test DB를 분리하기 위해서 local DB는 2가지로 나누어 세팅을 해야한다.
그런데 test를 실행할때마다 typeORM 세팅의 연결값을 매번 변경해줘야하는 문제가 상당히 번거로웠다. 고민하던 와중, cross-env라는 npm package를 알게되었고 이를 이용하여 상황에 따라 dotenv 설정값을 유동적으로 활용할 수 있도록 세팅을 구상해보았다.
요약.
JEST의 test파일 실행시 기존 DB를 사용함으로 인한 DB내부 데이터 오염문제 test용 DB 분리로 해결 test용 DB 분리 이후, npm run 실행 환경(dev, test, production)에 따른 DB 설정문제 개발간 서버를 돌릴때, test코드를 돌릴때마다 dev.]]></description>
</item>
<item>
    <title>nestJS 시작하기</title>
    <link>https://inchan.dev/posts/202301090435/</link>
    <pubDate>Mon, 09 Jan 2023 04:35:58 &#43;0900</pubDate>
    <author>inchan</author>
    <guid>https://inchan.dev/posts/202301090435/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/images/Pasted%20image%2020230301063722.png" referrerpolicy="no-referrer">
            </div>nestJS - cli 설치 사전 조건 : node lts버전 설치
npm i @nestjs/cli 또는
npm i -g @nestjs/cli 이렇게 package.json 파일에서 정상적으로 설치되었음을 확인할 수 있다.
nestJS - new Project 시작하기 nest new &lt;new project name&gt; // 예시 nest new nestjs-test 위와 같이 입력하면 현재 터미널이 위치한 폴더 내에 새로운 &ldquo;nestjs-test&quot;폴더가 만들어지면서 그 안에 세팅이 된다.
만약 $ mkdir nestjs-test 로 폴더를 만들고 이 위치에서 진행중이라면,
nest new ./ 위와 같이 입력시 현재 폴더명 그대로 새로운 프로젝트가 진행된다.]]></description>
</item>
</channel>
</rss>
