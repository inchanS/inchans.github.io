<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>mySQL - Tag - inchan.dev</title>
        <link>https://www.inchan.dev/tags/mysql/</link>
        <description>mySQL - Tag - inchan.dev</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>song@inchan.dev (inchan)</managingEditor>
            <webMaster>song@inchan.dev (inchan)</webMaster><lastBuildDate>Sat, 25 Feb 2023 04:14:31 &#43;0900</lastBuildDate><atom:link href="https://www.inchan.dev/tags/mysql/" rel="self" type="application/rss+xml" /><item>
    <title>typeORM transaction에서 repository 사용하기</title>
    <link>https://www.inchan.dev/posts/230225-typeorm-transaction%EC%97%90%EC%84%9C-repository-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</link>
    <pubDate>Sat, 25 Feb 2023 04:14:31 &#43;0900</pubDate>
    <author>inchan</author>
    <guid>https://www.inchan.dev/posts/230225-typeorm-transaction%EC%97%90%EC%84%9C-repository-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</guid>
    <description><![CDATA[#project_review #typeorm
transaction 구성중 Entity가 아닌 Repository 사용시 typeORM에서 transaction을 사용하는 방법은 몇가지가 있지만,
복잡한 service단의 처리에서는 아래의 queryRunner 방식이 더 적합할것 같아서
dataSource.createQueryRunner() 방식을 사용했다.1
// transaction으로 묶어주기 const queryRunner = dataSource.createQueryRunner(); await queryRunner.connect(); await queryRunner.startTransaction(); try { // feed 저장 let newTempFeed: Feed = plainToInstance(FeedDto, feedInfo); const tempFeed = await FeedRepository.createFeed(newTempFeed); //&lt;- 문제!! // ... 추가 코드들 } catch (err) { await queryRunner.rollbackTransaction(); throw new Error(`createTempFeed TRANSACTION error: ${err}`); } finally { await queryRunner.]]></description>
</item>
</channel>
</rss>
